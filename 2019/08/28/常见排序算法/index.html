<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Juliet&#39;s blog">
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/junlian.github.io/img/favicon.ico">

    <title>
        
        常见排序算法 - 学 | 慢慢来
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/junlian.github.io/css/aircloud.css">
    <link rel="stylesheet" href="/junlian.github.io/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所谓诚其意者，毋自欺也，如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也。 ——摘《大学》 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/junlian.github.io/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>慎思之，笃行之</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/junlian.github.io/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/junlian.github.io/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/junlian.github.io/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/junlian.github.io/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-术语"><span class="toc-text">1. 术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-常用排序算法"><span class="toc-text">2. 常用排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-冒泡排序-Bubble-Sort"><span class="toc-text">2.1 冒泡排序 Bubble Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-选择排序-Selection-Sort"><span class="toc-text">2.2 选择排序 Selection Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-插入排序-Insertion-Sort"><span class="toc-text">2.3 插入排序 Insertion Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-希尔排序"><span class="toc-text">2.4 希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-归并排序-Merge-Sort"><span class="toc-text">2.5 归并排序 Merge Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-快速排序"><span class="toc-text">2.6 快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-堆排序-Heap-Sort"><span class="toc-text">2.7 堆排序 Heap Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造最大堆"><span class="toc-text">构造最大堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最大堆插入"><span class="toc-text">最大堆插入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-计数排序-Counting-Sort"><span class="toc-text">2.8 计数排序 Counting Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-桶排序-Bucket-Sort"><span class="toc-text">2.9 桶排序 Bucket Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-基数排序"><span class="toc-text">2.10 基数排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法总结"><span class="toc-text">算法总结</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 所谓诚其意者，毋自欺也，如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也。 ——摘《大学》 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        常见排序算法
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-08-28 13:28:09</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h2 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h2><p><strong>稳定 or 不稳定</strong></p>
<ul>
<li>稳定：如果a = b, 排序前 a 在 b 前面，排序后 a 仍然在 b 前面；</li>
<li>不稳定：排序后 a 可能会出现在 b 后面；</li>
</ul>
<p><strong>内排序 or 外排序</strong></p>
<ul>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据量大内存中装不下，需要把一部分放在磁盘中，排序需要经过磁盘和内存的数据传输才能进行。</li>
</ul>
<p><strong>比较 or 非比较</strong></p>
<ul>
<li>比较：元素之间的次序依赖于它们之间的比较；</li>
<li>非比较：通过确定每个元素之前应该有多少个元素来排序，如计数排序、基数排序、桶排序。</li>
</ul>
<p><strong>In-place or Out-place</strong></p>
<ul>
<li>In-place: 不占用额外内存 或 占用常数内存；</li>
<li>Out-place: 占用额外内存</li>
</ul>
<p><strong>空间复杂度</strong>所需内存大小。</p>
<h2 id="2-常用排序算法"><a href="#2-常用排序算法" class="headerlink" title="2. 常用排序算法"></a>2. 常用排序算法</h2><h3 id="2-1-冒泡排序-Bubble-Sort"><a href="#2-1-冒泡排序-Bubble-Sort" class="headerlink" title="2.1 冒泡排序 Bubble Sort"></a>2.1 冒泡排序 Bubble Sort</h3><p>重复访问要排序的数列，一次比较两个元素，如果顺序错误就交换，重复访问一直到没有需要交换的元素为止，“冒泡”是说越小的元素会慢慢通过交换“浮”到数列的前面。</p>
<p><strong>【算法】</strong>比较相邻的元素，如果第一个比第二个大，就交换；一轮比下来，放在最后的元素就是最大的树；重复该步骤，每次都除去上一轮比较的最后一个元素。</p>
<p><strong>【复杂度】</strong><br>最佳：$T(n) = O(n)$<br>最差：$T(n) = O(n^2)$<br>平均：$T(n) = O(n^2)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array) - <span class="number">1</span> - i):</span><br><span class="line">            <span class="keyword">if</span> array[j+<span class="number">1</span>] &lt; array[j]:</span><br><span class="line">                array[j+<span class="number">1</span>], array[j] = array[j], array[j+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h3 id="2-2-选择排序-Selection-Sort"><a href="#2-2-选择排序-Selection-Sort" class="headerlink" title="2.2 选择排序 Selection Sort"></a>2.2 选择排序 Selection Sort</h3><p>在未排序的序列中找到最小元素，放到序列的其实位置，在从剩余未排序的元素中继续找最小元素，…, 直到所有元素排完。</p>
<p><strong>【算法】</strong><br>初始状态有序区为空，无序区为n个，每趟排列中，从当前无序区中找到最小元素，将它和无序区的第1个元素交换，有序区元素多1个，无序区元素少1个，重复该过程 … n 个元素要经过 n - 1 趟选择排序得到有序结果。</p>
<p><strong>【复杂度】</strong><br>无论什么数据都是$O(n^2)$的时间复杂度，表现稳定，唯二的好处就是容易想到，不占用额外的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def selectionSort(array):</span><br><span class="line">    if len(array) &lt;= 1:</span><br><span class="line">        return array</span><br><span class="line">    for i in range(len(array)):</span><br><span class="line">        minIndex = i</span><br><span class="line">        for j in range(i, len(array)):</span><br><span class="line">            if array[j] &lt; array[minIndex]:</span><br><span class="line">                minIndex = j</span><br><span class="line">        array[i], array[minIndex] = array[minIndex], array[i]</span><br><span class="line">    return array</span><br></pre></td></tr></table></figure>
<h3 id="2-3-插入排序-Insertion-Sort"><a href="#2-3-插入排序-Insertion-Sort" class="headerlink" title="2.3 插入排序 Insertion Sort"></a>2.3 插入排序 Insertion Sort</h3><p>思路是每次从无序数列中拿出一个值，插入到有序序列的相应位置，来构建有序序列。通常in-place排序，所以只需要$O(1)$的额外空间，在从后往前扫描中，需要把已排序的元素逐个往后挪位，为新元素空出插入位置。</p>
<p><strong>【算法】</strong>从第一个元素开始，认为该元素已排好序；取出下一个元素，在已排好的元素序列中从后往前扫描，每扫到一个元素，如果该元素大于新元素，则将该元素后移一位，直到找到某个元素小于或等于新元素，将新元素插入到该位置之后。</p>
<p><strong>【复杂度】</strong><br>最佳：$T(n) = O(n)$<br>最差：$T(n) = O(n^2)$<br>平均：$T(n) = O(n^2)$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def insertionSort(array):</span><br><span class="line">    if len(array) &lt;= 1:</span><br><span class="line">        return array</span><br><span class="line">    for i in range(1, len(array)):</span><br><span class="line">        cur = array[i]</span><br><span class="line">        preIndex = i - 1</span><br><span class="line">        while preIndex &gt;= 0 and cur &lt; array[preIndex]:</span><br><span class="line">            array[preIndex + 1] = array[preIndex]</span><br><span class="line">            preIndex -= 1</span><br><span class="line">        array[preIndex + 1] = cur</span><br><span class="line">    return array</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-希尔排序"><a href="#2-4-希尔排序" class="headerlink" title="2.4 希尔排序"></a>2.4 希尔排序</h3><p>也是一种插入排序，是Donald Shell 把简单插入排序改进之后的一个更高效的排序，该算法是冲破$O(n^2)$的第一批算法之一。与插入排序的区别在于，它会优先比较距离较远的元素，所以也称缩小增量排序。思路是把记录按一定的增量分组，再对每个组使用插入排序算法，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件被分为一组。</p>
<p><strong>【算法】</strong>选择一个增量序列 $t_1, t_2, …, t_k$，其中$t_i &gt; t_j, t_k =1$，比如用希尔增量 {n/2, n/4, …, 1}（但其实这个增量序列不是最优的），按增量序列个数k，对序列进行k趟排序，每趟排序中，先根据增量$t_i$将待排序序列分割成$t_i$组子序列分别进行插入排序，若$t_i = 5$，则第一组子序列为{0, 5, 10, …}，第2组为{1, 6, 11,…} …，这样每次仅需要对前面的数列进行简单微调，而不用大量移动元素。</p>
<p><strong>【复杂度】</strong><br>最佳：$T(n) = O(nlog_2 n)$<br>最差：$T(n) = O(nlog_2 n)$<br>平均：$T(n) = O(nlog_2 n)$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def shellSort(array):</span><br><span class="line">    gap = len(array) // 2</span><br><span class="line">    while gap &gt; 0:</span><br><span class="line">        for i in range(gap, len(array)):</span><br><span class="line">            tmp = array[i]</span><br><span class="line">            preIndex = i - gap</span><br><span class="line">            while preIndex &gt;= 0 and array[preIndex] &gt; tmp:</span><br><span class="line">                array[preIndex + gap] = array[preIndex]</span><br><span class="line">                preIndex -= gap</span><br><span class="line">            array[preIndex + gap] = tmp</span><br><span class="line">        gap //= 2</span><br><span class="line">    return array</span><br></pre></td></tr></table></figure>
<h3 id="2-5-归并排序-Merge-Sort"><a href="#2-5-归并排序-Merge-Sort" class="headerlink" title="2.5 归并排序 Merge Sort"></a>2.5 归并排序 Merge Sort</h3><p>是建立再归并操作上的排序算法，采用分治法，先将待排序序列分为子序列，每个子序列再使用归并排序，再将已有序的子序列合并，是一种稳定的排序算法。2-路归并就是将两个有序序列合并成一个有序序列。</p>
<p><strong>【算法】</strong>把长度为 n 的序列分为两个长度为 n/2 的子序列；对这两个子序列分别进行归并排序；将两个排好序的子序列合并成最终的排序序列。<br><strong>【复杂度】</strong><br>性能不受输入数据的影响，始终都是$O(nlogn)$，代价是需要额外的内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    mid = len(array) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> merge(MergeSort(array[:mid], MergeSort(array[mid:])))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    left_idx = right_idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(right) + len(left)):</span><br><span class="line">        <span class="keyword">if</span> left_idx &gt;= len(left):</span><br><span class="line">            res += right[right_idx:]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> right_idx &gt;= len(right):</span><br><span class="line">            res += left[left_idx:]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> left[left_idx] &gt; right[right_idx]:</span><br><span class="line">            res.append(right[right_idx])</span><br><span class="line">            right_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(left[left_idx])</span><br><span class="line">            left_idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="2-6-快速排序"><a href="#2-6-快速排序" class="headerlink" title="2.6 快速排序"></a>2.6 快速排序</h3><p>通过一趟排序把待排序序列分成两部分，其中一部分中的元素都比另一部分的元素小，然后继续分别对两部分用同样的方法排序。</p>
<p><strong>【算法】</strong>用分治法，从序列中挑一个元素作为基准，所有比基准元素小的放在前面，所有比基准元素大的放在基准元素后面，相同的数可以放在任意边（所以不稳定），一趟排序后，基准元素就已位于排序后的正确位置，这个过程称为partition。对小于基准和大于基准的子序列分别递归地排序。</p>
<p><strong>【复杂度】</strong><br>最佳：$T(n) = O(nlog_2 n)$<br>最差：$T(n) = O(n^2)$<br>平均：$T(n) = O(nlog_2 n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">return</span> quickSort_helper(array, <span class="number">0</span>, len(array)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort_helper</span><span class="params">(array, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">1</span> <span class="keyword">or</span> start &lt; <span class="number">0</span> <span class="keyword">or</span> end &gt;= len(array) <span class="keyword">or</span> start &gt; end:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    smallIndex = partition(array, start, end)</span><br><span class="line">    <span class="keyword">if</span> smallIndex &gt; start:</span><br><span class="line">        quickSort_helper(array, start, smallIndex - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> smallIndex &lt; end:</span><br><span class="line">        quickSort_helper(array, smallIndex + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, start, end)</span>:</span></span><br><span class="line">    pivot = int(start + random.random() * (end - start + <span class="number">1</span>))</span><br><span class="line">    smallIndex = start - <span class="number">1</span>  <span class="comment"># smallIndex之前的所有元素都比pivot小，退出时smallIndex上放的是pivot</span></span><br><span class="line">    array[pivot], array[end] = array[end], array[pivot]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> array[i] &lt;= array[end]:</span><br><span class="line">            smallIndex += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; smallIndex:</span><br><span class="line">                array[i], array[smallIndex] = array[smallIndex], array[i]</span><br><span class="line">    <span class="keyword">return</span> smallIndex</span><br></pre></td></tr></table></figure>
<h3 id="2-7-堆排序-Heap-Sort"><a href="#2-7-堆排序-Heap-Sort" class="headerlink" title="2.7 堆排序 Heap Sort"></a>2.7 堆排序 Heap Sort</h3><p>利用最小堆或最大堆实现。</p>
<p><strong>【算法】</strong>将待排序序列构建成大顶堆，此时堆顶为最大元素，将堆顶元素R[1] 和最后一个元素 R[n] 交换，得到无序区 $(R1, R2, …, Rn-1)$ 和 有序区 Rn，且 $(R1, R2, …, Rn-1)$ &lt;= Rn；交换后重新将无序区调整为最大堆，然后再和无序区最后一个元素交换…重复此过程知道有序区元素个数为n-1。</p>
<p><strong>【复杂度】</strong><br>最佳：$T(n) = O(nlog_2 n)$<br>最差：$T(n) = O(nlog_2 n)$<br>平均：$T(n) = O(nlog_2 n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    length = len(array)</span><br><span class="line">    buildMaxHeap(array)</span><br><span class="line">    <span class="keyword">while</span> length &gt; <span class="number">0</span>:</span><br><span class="line">        array[<span class="number">0</span>], array[length - <span class="number">1</span>] = array[length - <span class="number">1</span>], array[<span class="number">0</span>]</span><br><span class="line">        length -= <span class="number">1</span></span><br><span class="line">        adjustHeap(array, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildMaxHeap</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((len(array)<span class="number">-1</span>)//<span class="number">2</span>, <span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        adjustHeap(array, i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjustHeap</span><span class="params">(array, i)</span>:</span></span><br><span class="line">    maxIndex = i</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt; len(array)) <span class="keyword">and</span> array[i * <span class="number">2</span>] &gt; array[maxIndex]:</span><br><span class="line">        maxIndex = i * <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len(array)) <span class="keyword">and</span> array[i*<span class="number">2</span>+<span class="number">1</span>] &gt; array[maxIndex]:</span><br><span class="line">        maxIndex = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> maxIndex != i:</span><br><span class="line">        array[maxIndex], array[i] = array[i], array[maxIndex]</span><br><span class="line">        adjustHeap(array, maxIndex)</span><br></pre></td></tr></table></figure>
<p>等比数列求和公式：</p>
<script type="math/tex; mode=display">S_n = \frac{a_1 (1-q^n)}{1-q} (q\ne 1)</script><p>完全二叉树性质</p>
<ul>
<li>满二叉树： 深度为k，且有$2^{k+1} - 1$ 个节点的二叉树，称为满二叉树，特点是每一层的节点数都是最大节点数。</li>
<li>完全二叉树：除最后一层外，其余所有层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点。</li>
<li><p>高度/深度：层数k，<strong>height(root) = 0</strong></p>
</li>
<li><p>完全二叉树具有n个节点的的深度为 $k=log_2n$</p>
</li>
<li>满二叉树第 i 层的节点数为 $2^i$</li>
<li>完全二叉树最后一层节点数为 $n - (2^k - 1) = n + 1 - 2^k$</li>
<li><p>完全二叉树左子树的节点数为：</p>
<script type="math/tex; mode=display">
\begin{equation}
l(n) = \left\{
\begin{array}{ll}
n-2^{k-1}, & n+1-2^k \le 2^{k-1} \\
2^k - 1 & n+1-2^k > 2^{k-1}
\end{array}
\right.
\end{equation}</script><p>$n+1-2^k \le 2^{k-1}$ 表示最后一层节点数小于满二叉树的k-1层节点数，即最后一层节点全在左子树，所以右子树为满二叉树，其深度为k-2，所以节点数为$2^k-1 - 1$</p>
<p>当 $n+1-2^k &gt; 2^{k-1}$时，左子树为满二叉树。</p>
</li>
<li><p>完全二叉树右子树：$r(n) = n-l(n)$</p>
</li>
</ul>
<p><strong>堆树</strong><br>堆树是一个完全二叉树，每个节点的值总是不大于或不小于其孩子节点的值，每个节点的子树都是堆树。</p>
<p>堆树的操作<br>以最大堆为例，原始数据用顺序存储方式 a = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7}，对应的完全二叉树为：<br><img src="./1566925908335.png" alt="Alt text"></p>
<h4 id="构造最大堆"><a href="#构造最大堆" class="headerlink" title="构造最大堆"></a>构造最大堆</h4><p>基本思想是，首先将每个叶子节点视为一个堆，再将每个叶子节点与其父节点一起构造成包含更多节点的堆。所以在构造的时候，首先要找到最后一个节点的父节点，从这个节点开始构造最大堆，直到该节点前面的所有分支节点都处理完毕，最大堆就构造完成了。</p>
<p>假设树有n 个节点，<strong>对于节点 i，其父节点为 $i/2$，左孩子节点为 $2i$，右孩子节点为 $2i+1$</strong>，最后一个节点的下标为 n，其父节点的下标为 n/2</p>
<h4 id="最大堆插入"><a href="#最大堆插入" class="headerlink" title="最大堆插入"></a>最大堆插入</h4><p>先在最后的节点添加一个元素，然后沿着树上升。</p>
<h3 id="2-8-计数排序-Counting-Sort"><a href="#2-8-计数排序-Counting-Sort" class="headerlink" title="2.8 计数排序 Counting Sort"></a>2.8 计数排序 Counting Sort</h3><p>核心在于把输入的数据转化为键存储在额外开辟的空间中，要求输入数据必须是有确定范围的整数，是一种<strong>稳定</strong>的排序，用一个额外的数组C存储每个元素出现的个数，第 i 个元素是等于 i 的元素的个数，<strong>只能对整数进行排序</strong>。</p>
<p><strong>【算法】</strong>找出待排序数组中最大和最小的元素；统计数组中每个值为 i 的元素出现的次数，存入数组C的第i项；累加所有计数，反向填充目标数组，将每个元素i放在新数组的第C(i) 项，每放一个元素C(i)减1。</p>
<p><strong>【复杂度】</strong><br>不是比较排序，空间复杂度取决于待排序数组中数据的范围（max-min + 1），当数据范围很大时空间复杂度很高，当输入的数据是 n 个 0 到 k 之间的整数时：<br>最佳：$T(n) = O(n+k)$<br>最差：$T(n) = O(n+k)$<br>平均：$T(n) = O(n+k)$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def CountingSort(array):</span><br><span class="line">    if len(array) &lt;= 1:</span><br><span class="line">        return array</span><br><span class="line">    min_v = min(array)</span><br><span class="line">    max_v = max(array)</span><br><span class="line">    bias = 0 - min_v;</span><br><span class="line">    res = []</span><br><span class="line">    counter = [0] * (max_v - min_v + 1)</span><br><span class="line">    for i in range(len(array)):</span><br><span class="line">        counter[array[i] + bias] += 1</span><br><span class="line">    idx = 0; i = 0</span><br><span class="line">    while idx &lt; len(array):</span><br><span class="line">        if counter[i] != 0:</span><br><span class="line">            array[idx] = i - bias</span><br><span class="line">            counter[i] -= 1</span><br><span class="line">            idx += 1</span><br><span class="line">        else:</span><br><span class="line">            i += 1</span><br><span class="line">    return array</span><br></pre></td></tr></table></figure></p>
<h3 id="2-9-桶排序-Bucket-Sort"><a href="#2-9-桶排序-Bucket-Sort" class="headerlink" title="2.9 桶排序 Bucket Sort"></a>2.9 桶排序 Bucket Sort</h3><p>计数排序的升级，函数映射的选择决定了算法是否高效，工作原理是假设输入数据服从均匀分布，把数据分到有限数量的桶里，分别对每个桶用其他排序算法或继续桶排序递归来进行排序。</p>
<p><strong>【算法】</strong>设置BucketSize，表示每个桶能放多少个不同数值，但每个数值的容量不限，也就是同一数值不管有多少个都可以放入一个桶；遍历输入数据，加入对应的桶；对非空桶继续排序；从非空桶中把排好序的数据拼接起来。</p>
<p><strong>【复杂度】</strong><br>最佳：$T(n) = O(n+k)$<br>最差：$T(n) = O(n+k)$<br>平均：$T(n) = O(n+k)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span><span class="params">(array, bucketSize)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    mmax = max(array)</span><br><span class="line">    mmin = min(array)</span><br><span class="line">    bucketCount = (mmax - mmin) / bucketSize + <span class="number">1</span></span><br><span class="line">    bucketArray = [[] * bucketCount] </span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        bucketArray[(array[i] - mmin]) / bucketSize].append(array[i])  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(bucketCount):</span><br><span class="line">        <span class="keyword">if</span> bucketCount == <span class="number">1</span>:</span><br><span class="line">            bucketSize -= <span class="number">1</span></span><br><span class="line">        tmp = bucketSort(bucketArray[i], bucketSize)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">            res.append(tmp[j])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="2-10-基数排序"><a href="#2-10-基数排序" class="headerlink" title="2.10 基数排序"></a>2.10 基数排序</h3><p>基数排序是对每一位进行排序，从最低位开始，一步步往最高位排序，如果数据的属性有优先级，先按低优先级排序，再按高优先级排序。</p>
<p><strong>【算法】</strong>找到序列中的最大数，得到最大值的位数；从最低位开始取每个位组成radix数组，用计数排序对radix排序，用计数排序是因为它适用于小范围的数。</p>
<p><strong>【复杂度】</strong><br>对序列长度为n, 最大数的位数为 k 的序列排序：<br>最佳，最差，平均：$T(n) = O(kn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radixSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    mmax = max(array)</span><br><span class="line">    maxDigit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> mmax != <span class="number">0</span>:</span><br><span class="line">        mmax //= <span class="number">10</span></span><br><span class="line">        maxDigit += <span class="number">1</span></span><br><span class="line">    bucketList = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    mod = <span class="number">10</span>; div = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(maxDigit):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            num = (array[j] % mod) // div</span><br><span class="line">            bucketList[num].append(array[j])</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(bucketList)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(len(bucketList[j])):</span><br><span class="line">                array[index] = bucketList[j][k]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            bucketList[j] = []</span><br><span class="line">        mod *= <span class="number">10</span>; div *= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h2 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th>算法</th>
<th>平均时间复杂度</th>
<th>最好</th>
<th>最坏</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>In or Out</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
<td>In-place</td>
</tr>
<tr>
<td>选择</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
<td>In-place</td>
</tr>
<tr>
<td>插入</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
<td>In-place</td>
</tr>
</tbody>
</table>
</div>
<p>计数排序、桶排序和基数排序都利用了桶的概念：</p>
<ul>
<li>计数排序：每个桶只有一个键值；</li>
<li>桶排序：每个桶存一定范围内的数值；</li>
<li>基数排序：根据键值的每位数字来分配桶。</li>
</ul>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });

</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->

</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/junlian.github.io/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/junlian.github.io/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
