<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Juliet&#39;s blog">
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/junlian.github.io/img/favicon.ico">

    <title>
        
        《剑指offer》 - 学 | 慢慢来
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/junlian.github.io/css/aircloud.css">
    <link rel="stylesheet" href="/junlian.github.io/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所谓诚其意者，毋自欺也，如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也。 ——摘《大学》 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/junlian.github.io/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>慎思之，笃行之</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/junlian.github.io/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/junlian.github.io/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/junlian.github.io/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/junlian.github.io/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题6：从尾到头打印链表"><span class="toc-text">面试题6：从尾到头打印链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-22：链表中倒数第-k-个节点"><span class="toc-text">面试题 22：链表中倒数第 k 个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-24：反转链表"><span class="toc-text">面试题 24：反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-25：合并两个排序的链表"><span class="toc-text">面试题 25：合并两个排序的链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题35：复杂链表的复制"><span class="toc-text">面试题35：复杂链表的复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题36：二叉搜索树与双向链表"><span class="toc-text">面试题36：二叉搜索树与双向链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题8：二叉树的下一个节点"><span class="toc-text">面试题8：二叉树的下一个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题6-：重建二叉树"><span class="toc-text">面试题6 ：重建二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-26：树的子结构"><span class="toc-text">面试题 26：树的子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题27：二叉树的镜像"><span class="toc-text">面试题27：二叉树的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题32：从上到下打印二叉树"><span class="toc-text">面试题32：从上到下打印二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题33：二叉搜索树的后序遍历序列"><span class="toc-text">面试题33：二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题34：二叉树中和为某一值的路径"><span class="toc-text">面试题34：二叉树中和为某一值的路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题4：二维数组中的查找"><span class="toc-text">面试题4：二维数组中的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-21-1-调整数组顺序使奇数位于偶数前面"><span class="toc-text">面试题 21-1 调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-21-2-调整数组奇前偶后，且保持相对位置"><span class="toc-text">面试题 21-2 调整数组奇前偶后，且保持相对位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-29：顺时针打印矩阵"><span class="toc-text">面试题 29：顺时针打印矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题39：数组中出现次数超过一半的数字"><span class="toc-text">面试题39：数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题40：最小的-k-个数"><span class="toc-text">面试题40：最小的 k 个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：滑动窗口的最大值"><span class="toc-text">面试题：滑动窗口的最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：矩阵中的路径"><span class="toc-text">面试题：矩阵中的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：机器人的运动范围"><span class="toc-text">面试题：机器人的运动范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题4：替换空格"><span class="toc-text">面试题4：替换空格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈和队列"><span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题7：用两个栈实现队列"><span class="toc-text">面试题7：用两个栈实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-30：包含min的栈"><span class="toc-text">面试题 30：包含min的栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-31：栈的压入、弹出序列"><span class="toc-text">面试题 31：栈的压入、弹出序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找"><span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题8：旋转数组的最小数字"><span class="toc-text">面试题8：旋转数组的最小数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归和循环"><span class="toc-text">递归和循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题9：斐波那契数列"><span class="toc-text">面试题9：斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题16：数值的整数次方"><span class="toc-text">面试题16：数值的整数次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题38：字符串的排列"><span class="toc-text">面试题38：字符串的排列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位运算"><span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题10：二进制中1的个数"><span class="toc-text">面试题10：二进制中1的个数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学"><span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题43：整数中1出现的次数（从1到n整数中1出现的次数）"><span class="toc-text">面试题43：整数中1出现的次数（从1到n整数中1出现的次数）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高质量代码"><span class="toc-text">高质量代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码完整性"><span class="toc-text">代码完整性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理方式"><span class="toc-text">错误处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题39：数组中出现次数超过一半的数字-1"><span class="toc-text">面试题39：数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题40：最小的-k-个数-1"><span class="toc-text">面试题40：最小的 k 个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-42：连续子数组的最大和"><span class="toc-text">面试题 42：连续子数组的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题43：整数中1出现的次数（从1到n整数中1出现的次数）-1"><span class="toc-text">面试题43：整数中1出现的次数（从1到n整数中1出现的次数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题45：把数组排成最小的数"><span class="toc-text">面试题45：把数组排成最小的数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题49：丑数"><span class="toc-text">面试题49：丑数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题50：第一个只出现一次的字符"><span class="toc-text">面试题50：第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题51：数组中的逆序对"><span class="toc-text">面试题51：数组中的逆序对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题52：两个链表的第一个公共结点"><span class="toc-text">面试题52：两个链表的第一个公共结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题-数字在排序数组中出现的次数"><span class="toc-text">面试题 数字在排序数组中出现的次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：二叉树的深度"><span class="toc-text">面试题：二叉树的深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：平衡二叉树"><span class="toc-text">面试题：平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：数组中只出现一次的数字"><span class="toc-text">面试题：数组中只出现一次的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：和为S的连续正数序列"><span class="toc-text">面试题：和为S的连续正数序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：和为S的两个数字"><span class="toc-text">面试题：和为S的两个数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题58-2：左旋转字符串"><span class="toc-text">面试题58-2：左旋转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题58-1：翻转单词顺序列"><span class="toc-text">面试题58-1：翻转单词顺序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题61：扑克牌中的顺子"><span class="toc-text">面试题61：扑克牌中的顺子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题62：圆圈中最后剩下的数字"><span class="toc-text">面试题62：圆圈中最后剩下的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题64：求1-2-3-…-n"><span class="toc-text">面试题64：求1+2+3+…+n</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题65：不用加减乘除做加法"><span class="toc-text">面试题65：不用加减乘除做加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题67：把字符串转换成整数"><span class="toc-text">面试题67：把字符串转换成整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：数组中重复的数字"><span class="toc-text">面试题：数组中重复的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：构建乘积数组"><span class="toc-text">面试题：构建乘积数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：正则表达式匹配"><span class="toc-text">面试题：正则表达式匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：表示数值的字符串"><span class="toc-text">面试题：表示数值的字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：字符流中第一个不重复的字符"><span class="toc-text">面试题：字符流中第一个不重复的字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：链表中环的入口结点"><span class="toc-text">面试题：链表中环的入口结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：删除链表中重复的结点"><span class="toc-text">面试题：删除链表中重复的结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：二叉树的下一个节点"><span class="toc-text">面试题：二叉树的下一个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：对称的二叉树"><span class="toc-text">面试题：对称的二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：按之字形顺序打印二叉树"><span class="toc-text">面试题：按之字形顺序打印二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：把二叉树打印成多行"><span class="toc-text">面试题：把二叉树打印成多行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：序列化二叉树"><span class="toc-text">面试题：序列化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题：二叉搜索树的第k个结点"><span class="toc-text">面试题：二叉搜索树的第k个结点</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 所谓诚其意者，毋自欺也，如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也。 ——摘《大学》 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        《剑指offer》
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-07-29 21:00:20</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="面试题6：从尾到头打印链表"><a href="#面试题6：从尾到头打印链表" class="headerlink" title="面试题6：从尾到头打印链表"></a>面试题6：从尾到头打印链表</h3><p>题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<p><strong>解法一：反转链表后从头到尾输出</strong><br>把链表中链接节点的指针反转过来，改变链表的方向，再从头到尾输出。这种解法的问题是会改变原来链表的结构。<strong>通常打印是一个只读操作，我们不希望打印时修改内容。</strong></p>
<blockquote>
<p>如果我们打算修改输入的数据，最好先问面试官是不是允许修改。</p>
</blockquote>
<p><strong>解法二：用栈实现</strong><br>遍历链表的顺序是从头到尾，输出的顺序是从尾到头，是典型的“后进先出”，所以可用栈来实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        ListNode* pNode = head;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodes.push(pNode);</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            pNode = nodes.top();</span><br><span class="line">            res.push_back(pNode-&gt;val);</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法三：递归实现</strong><br>递归在本质上就是一个栈结构，所以很自然由栈想到了用递归实现。每访问一个节点，先递归输出它后面的节点，再输出该节点自身：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                printListFromTailToHead(head-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该解法在牛客网无法通过：堆栈溢出（比如，递归调用层数太多）等情况引起。</p>
<h3 id="面试题-22：链表中倒数第-k-个节点"><a href="#面试题-22：链表中倒数第-k-个节点" class="headerlink" title="面试题 22：链表中倒数第 k 个节点"></a>面试题 22：链表中倒数第 k 个节点</h3><p><strong>题目：</strong>输入一个链表，输出该链表中倒数第k个结点。</p>
<p><strong>解题思路：</strong>双指针移动，前面的指针先单独移动$k-1$步，然后两个指针一起移动。注意 $k=0$，输入空指针，链表长度小于$k$的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pListHead == <span class="literal">nullptr</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pre = pListHead;</span><br><span class="line">        ListNode* last = pListHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123;     <span class="comment">// 往前移k-1步</span></span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> $k$ 是无符号整数，若  $k=0$，那么$k-1$ 将不等于 $-1$ ，而是等于 $4294967295$。 </p>
</blockquote>
<h3 id="面试题-24：反转链表"><a href="#面试题-24：反转链表" class="headerlink" title="面试题 24：反转链表"></a>面试题 24：反转链表</h3><p><strong>题目：</strong>输入一个链表，反转链表后，输出新链表的表头。<br><strong>解题思路：</strong> 假设当前移动到节点 i，将 i 指向前一个，所以当前步需要知道前一个节点 prev，将 i 指向前一个之前，要记录 i-&gt;next，否则链表断裂。用单独的一个reverseHead节点，记录反转后的头指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = pHead;</span><br><span class="line">        ListNode* reverseHead = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(next == <span class="literal">nullptr</span>) reverseHead = cur;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题-25：合并两个排序的链表"><a href="#面试题-25：合并两个排序的链表" class="headerlink" title="面试题 25：合并两个排序的链表"></a>面试题 25：合并两个排序的链表</h3><p><strong>题目：</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br><strong>解题思路：</strong>递归，注意处理空链表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode* resHead = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123;</span><br><span class="line">            resHead = pHead1;</span><br><span class="line">            resHead-&gt;next = Merge(pHead1-&gt;next, pHead2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resHead = pHead2;</span><br><span class="line">            resHead-&gt;next = Merge(pHead1, pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题35：复杂链表的复制"><a href="#面试题35：复杂链表的复制" class="headerlink" title="面试题35：复杂链表的复制"></a>面试题35：复杂链表的复制</h3><p><strong>题目：</strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<br><strong>解题思路：</strong>第一步根据原始链表的每个节点$N$创建对应的 $N’$ ，把 $N’$ 链接在$N$ 后，即$N1$-&gt;$N1’$-&gt;$N2$-&gt;$N2’$-&gt;$N3$-&gt;$N3’$-&gt; … ；第二步设置复制出来的节点的siblint，假设原始链表上的N的sibling指向节点S，那么其对应复制出来的$N’$是$N$的next指向的节点，$S’$ 也是$S’$ 的next指向的节点；第三步把长链表拆分成两个链表，把奇数位置的节点用next链接起来的就是原始链表，把偶数位置的节点用next链接起来就是复制出来的链表。</p>
<p><strong>解法一：递归，移动找最大最小</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        RandomListNode* pNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            RandomListNode* pClone = <span class="keyword">new</span> RandomListNode(pNode-&gt;label);</span><br><span class="line">            pClone-&gt;next = pNode-&gt;next;</span><br><span class="line">            pNode-&gt;next = pClone;</span><br><span class="line">            pNode = pClone-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;random != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pNode-&gt;next-&gt;random = pNode-&gt;random-&gt;next;</span><br><span class="line">                pNode = pNode-&gt;next-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pNode-&gt;next-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line">                pNode = pNode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">        pNode = pHead;</span><br><span class="line">        RandomListNode* pCloneHead = pHead-&gt;next;</span><br><span class="line">        RandomListNode* pCloneNode = pHead-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//if(pNode-&gt;next)</span></span><br><span class="line">            <span class="keyword">if</span>(pCloneNode-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                pNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode-&gt;next = pCloneNode-&gt;next;</span><br><span class="line">            pCloneNode-&gt;next = pCloneNode-&gt;next-&gt;next;</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">            pCloneNode = pCloneNode-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题36：二叉搜索树与双向链表"><a href="#面试题36：二叉搜索树与双向链表" class="headerlink" title="面试题36：二叉搜索树与双向链表"></a>面试题36：二叉搜索树与双向链表</h3><p><strong>题目：</strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><strong>解题思路：</strong>按照中序遍历的顺序，当我们遍历转化到根节点时，它的左子树已经是转换成一个排序的链表了，并且处在链表的最后一个节点是当前值最大的节点，把左子树最右边的节点指向根节点。接着转换右子树，把根节点和右子树中最小的节点链接起来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* node = helper(pRootOfTree);</span><br><span class="line">        <span class="keyword">while</span>(node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* pRootOfTree)</span></span>&#123;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            pre = helper(pRootOfTree-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            next = helper(pRootOfTree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                pre = pre-&gt;right;</span><br><span class="line">            pRootOfTree-&gt;left = pre;</span><br><span class="line">            pre-&gt;right = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(next-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                next = next-&gt;left;</span><br><span class="line">            pRootOfTree-&gt;right = next;</span><br><span class="line">            next-&gt;left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：递归，prenode 指针记录当前节点的上一节点</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* lastNode = <span class="literal">nullptr</span>;</span><br><span class="line">        helper(pRootOfTree, lastNode);</span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode*&amp; lastNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            helper(root-&gt;left, lastNode);</span><br><span class="line">        root-&gt;left = lastNode;</span><br><span class="line">        <span class="keyword">if</span>(lastNode != <span class="literal">nullptr</span>)</span><br><span class="line">            lastNode-&gt;right = root;</span><br><span class="line">        </span><br><span class="line">        lastNode = root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            helper(root-&gt;right, lastNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="面试题8：二叉树的下一个节点"><a href="#面试题8：二叉树的下一个节点" class="headerlink" title="面试题8：二叉树的下一个节点"></a>面试题8：二叉树的下一个节点</h3><p><strong>题目</strong>：给定一颗二叉树和其中的一个节点，找出中序遍历序列的下一个节点并返回。树中的节点不仅包含左右子节点，还包含指向父节点的指针。</p>
<p><strong>二叉树测试用例</strong></p>
<ul>
<li>普通二叉树：完全二叉树，不完全二叉树；</li>
<li>特殊二叉树：所有节点都没有左/右节点的二叉树，只有一个节点的二叉树；<strong>二叉树的根节点指针为nulptr</strong>；</li>
<li>不同位置的节点的下一节点。</li>
</ul>
<p><strong>解题思路</strong><br>画出二叉树的结构图，通过具体的例子找出中序遍历下一个节点的规律：</p>
<ul>
<li>如果一个节点有右子树，那么它的下一个节点就是它右子树中的最左子节点；</li>
<li>如果一个节点没有右子树，那么如果节点是它父节点的左子节点，那么它的下一个节点就是它的父节点；</li>
<li>如果一个节点既没有右子树，而且它还是父节点的右子节点，这种情况下，可以沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，如果这样的节点存在，那么这个节点的父节点就是我们要找的下一个节点；如果这样的节点不存在一直向上找到了根节点，那下一个节点不存在。</li>
</ul>
<p>写代码时后两种情况可以合并：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeLinkNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeLinkNode* pRight = pNode-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(pRight-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pRight = pRight-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pRight;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeLinkNode* pCurrent = pNode;</span><br><span class="line">            TreeLinkNode* pParent = pNode-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(pParent != <span class="literal">nullptr</span> &amp;&amp; pCurrent == pParent-&gt;right)&#123;</span><br><span class="line">                pCurrent = pParent;</span><br><span class="line">                pParent = pParent-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pParent;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题6-：重建二叉树"><a href="#面试题6-：重建二叉树" class="headerlink" title="面试题6 ：重建二叉树"></a>面试题6 ：重建二叉树</h3><p><strong>题目</strong>：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p><strong>解题思路</strong>：在二叉树的前序遍历序列中，第一个数字总是根节点，而在中序遍历序列中，根节点在序列的中间，根节点左边的值组成左子树，右边的值组成右子树。所以可以先根据前序遍历序列的第一个数字创建根节点，然后在中序遍历中找到根节点的位置，就可以确定左右子树节点的数量。划分出左右子树节点的值之后，就可以递归地调用函数，分别构建它的左右子树。</p>
<p><strong>解法一：递归法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.size() == <span class="number">0</span> || pre.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(pre, <span class="number">0</span>, pre.size() - <span class="number">1</span>, vin, <span class="number">0</span>, vin.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="keyword">int</span> p_start, <span class="keyword">int</span> p_end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin, <span class="keyword">int</span> i_start, <span class="keyword">int</span> i_end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_end &lt; p_start &amp;&amp; i_end &lt; i_start) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(pre[p_start]);</span><br><span class="line">        <span class="keyword">int</span> i = i_start;</span><br><span class="line">        <span class="keyword">while</span>(pre[p_start] != vin[i]) i += <span class="number">1</span>;</span><br><span class="line">        root-&gt;left = helper(pre, p_start + <span class="number">1</span>, p_start + i - i_start, vin, i_start, i - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = helper(pre, p_start + i - i_start + <span class="number">1</span>, p_end, vin, i + <span class="number">1</span>, i_end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：非递归法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.size() == <span class="number">0</span> || pre.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">stack</span>.push(root);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.size(); i ++)&#123;</span><br><span class="line">            TreeNode* cur_node = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;val != vin[index])&#123;</span><br><span class="line">                cur_node-&gt;left = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">                <span class="built_in">stack</span>.push(cur_node-&gt;left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">stack</span>.top()-&gt;val == vin[index])&#123;</span><br><span class="line">                    cur_node = <span class="built_in">stack</span>.top();</span><br><span class="line">                    <span class="built_in">stack</span>.pop();</span><br><span class="line">                    index += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur_node-&gt;right = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">                <span class="built_in">stack</span>.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题-26：树的子结构"><a href="#面试题-26：树的子结构" class="headerlink" title="面试题 26：树的子结构"></a>面试题 26：树的子结构</h3><p><strong>题目：</strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p><strong>解题思路：</strong>可分为两步：（1）第一步在树A中找到和树B的根节点值一样的节点R，实际上就是<strong>树的遍历</strong>，如果没有特别要求就用遍历，如果发现符合条件的节点，则调用第二步的函数判断；（2）第二步判断A中以R为根节点的子树是不是包含和树B一样的结构，也可以用递归的思路来考虑，如果根节点不同，则肯定不同，如果根节点相同，则递归地判断他们各自的左右节点的值是不是相同。<strong>递归的终止条件是到达了子树A或子树B的叶节点</strong>。</p>
<blockquote>
<ol>
<li>与二叉树相关的代码有大量的指针操作，在每次使用指针时，都要问自己这个指针有没有可能是nullptr。<br>判断两个double值是否相等，只能判断它们之差的绝对值是不是在一个很小的范围内。如果两个树相差很小，就可以认为它相等 <code>if((num1-num2 &gt; -0.0000001) &amp;&amp; (num1-num2 &lt; 0.0000001))</code></li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 != <span class="literal">nullptr</span> &amp;&amp; pRoot2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)&#123;</span><br><span class="line">                res = DoesTreeAHasTreeB(pRoot1, pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                res = HasSubtree(pRoot1-&gt;left, pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                res = HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DoesTreeAHasTreeB</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;           <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val != pRoot2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (DoesTreeAHasTreeB(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; DoesTreeAHasTreeB(pRoot1-&gt;right, pRoot2-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题27：二叉树的镜像"><a href="#面试题27：二叉树的镜像" class="headerlink" title="面试题27：二叉树的镜像"></a>面试题27：二叉树的镜像</h3><p><strong>题目：</strong>操作给定的二叉树，将其变换为源二叉树的镜像。<br><strong>解题思路：</strong>先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个节点，当交换完所有非叶节点的子节点后，就得到了树的镜像。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left == <span class="literal">nullptr</span> &amp;&amp; pRoot-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* tmp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = tmp;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left) Mirror(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;right) Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题32：从上到下打印二叉树"><a href="#面试题32：从上到下打印二叉树" class="headerlink" title="面试题32：从上到下打印二叉树"></a>面试题32：从上到下打印二叉树</h3><p><strong>题目：</strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br><strong>解题思路：</strong>用队列实现，每次打印一个节点的时候，如果该节点有子节点，则把该节点的子节点放到一个队列的末尾。接下来队列的头部取出最早进入队列的节点，重复前面的打印操作，直到队列中所有节点都被打印出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; node_queue;</span><br><span class="line">        node_queue.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!node_queue.empty())&#123;</span><br><span class="line">            TreeNode* cur = node_queue.front();</span><br><span class="line">            node_queue.pop();</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left != <span class="literal">nullptr</span>) node_queue.push(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right != <span class="literal">nullptr</span>) node_queue.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题33：二叉搜索树的后序遍历序列"><a href="#面试题33：二叉搜索树的后序遍历序列" class="headerlink" title="面试题33：二叉搜索树的后序遍历序列"></a>面试题33：二叉搜索树的后序遍历序列</h3><p><strong>题目：</strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><strong>解题思路：</strong>用递归法，每次递归的后序遍历得到的序列中，最后一个数字是树的根节点的值，数组中前面的数字可分为两部分，第一部分是左子树节点的值，它们都比根节点的值小，第二部分是右子树节点的值，它们都比根节点的值大。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(sequence, <span class="number">0</span>, sequence.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start;</span><br><span class="line">        <span class="keyword">while</span>(mid &lt; end &amp;&amp; sequence[mid] &lt; sequence[end]) mid ++;</span><br><span class="line">        <span class="keyword">int</span> right = mid;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[right] &lt; sequence[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(sequence, start, mid - <span class="number">1</span>) &amp;&amp; helper(sequence, mid, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题34：二叉树中和为某一值的路径"><a href="#面试题34：二叉树中和为某一值的路径" class="headerlink" title="面试题34：二叉树中和为某一值的路径"></a>面试题34：二叉树中和为某一值的路径</h3><p><strong>题目：</strong>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)<br><strong>解题思路：</strong>当用前序遍历 (先访问根节点) 的方式访问到某一节点时，我们把该节点添加到路径上，并累加该记诶单的值。<strong>如果该节点为叶节点</strong>，并且路径中节点值的和刚好等于输入的整数，则当前路径符合要求，记录下来。如果当前节点不是叶节点，则继续访问它的子节点。当前节点访问结束后，递归函数将自动回到它的父节点，因此，我们<strong>在函数退出之前要在路径上删除当前节点并减去当前节点的值</strong>，以确保返回父节点时的路径刚好是从根节点到父节点。整体来看保存路径的数据结构实际上是一个栈，因为路径要与递归调用状态一致，而递归调用的本质就是一个压栈出栈的过程。</p>
<p><strong>解法一：递归法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_list;</span><br><span class="line">    <span class="keyword">int</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        cur_sum += root-&gt;val;</span><br><span class="line">        v_list.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur_sum == expectNumber &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) res.push_back(v_list);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>) FindPath(root-&gt;left, expectNumber);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>) FindPath(root-&gt;right, expectNumber);</span><br><span class="line">        cur_sum -= root-&gt;val;</span><br><span class="line">        v_list.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：非递归法</strong><br>用辅助栈，进栈时把值同时压入路径的向量数组，修正路径值的和；出栈的时候，先判断和是否相等，且该节点是否是叶节点；当前节点判断完成后恢复栈，从当前路径中抛出节点，修改路径和。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; helper;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_list;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(root || !helper.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                helper.push(root);</span><br><span class="line">                v_list.push_back(root-&gt;val);</span><br><span class="line">                expectNumber -= root-&gt;val;</span><br><span class="line">                root = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            root = helper.top();</span><br><span class="line">            <span class="keyword">if</span>(expectNumber == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                res.push_back(v_list);</span><br><span class="line">            helper.pop();</span><br><span class="line">            v_list.pop_back();</span><br><span class="line">            expectNumber += root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(!helper.empty() &amp;&amp; helper.top()-&gt;left == root)</span><br><span class="line">                root = helper.top()-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                root = <span class="literal">NULL</span>;        <span class="comment">// 右子树遍历过，强迫出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="面试题4：二维数组中的查找"><a href="#面试题4：二维数组中的查找" class="headerlink" title="面试题4：二维数组中的查找"></a>面试题4：二维数组中的查找</h3><p><strong>题目</strong>：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>解题思路</strong>：这个题目只要从一个具体的二维数组的右上角/左下角开始分析，就能找到突破口，以右上角为例，选择数组中右上角的数字：<br>（1）如果该数字等于要查找的数字，则查找过程结束；<br>（2）如果该数字大于要查找的数字，则剔除这个数字所在的列；因为右上角的数字是该列中最小的值，如果要查找的数字比这个还小，则肯定不会出现在这一列中。<br>（3）如果该数字小于要查找的数字，则剔除这个数字所在的行；</p>
<p>也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围内剔除一行或一列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[<span class="number">0</span>].size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> col = <span class="built_in">array</span>[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(row &lt; <span class="built_in">array</span>.size() &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[row][col] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[row][col] &gt; target) col -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> row += <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题-21-1-调整数组顺序使奇数位于偶数前面"><a href="#面试题-21-1-调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题 21-1 调整数组顺序使奇数位于偶数前面"></a>面试题 21-1 调整数组顺序使奇数位于偶数前面</h3><p><strong>题目：</strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p>
<p><strong>解法一：奇偶指针</strong><br>维护两个指针，第一个指针初始化时指向数组的第一个数组，它只向后移动，第二个指针初始化时指向数组的最后一个数字，它只向前移动，在两个指针相遇之前，第一个指针总是位于第二个指针的前面。如果第一个指针指向的数字是偶数，并且第二个指针指向的是奇数，就交换这两个数字。</p>
<p><strong>解法二：可扩展编程</strong><br>考虑到“按奇数在前，偶数在后”，可以换为“负数在前，非负数在后”、“能被3整除的在前，不能整除的在后”… 我们要提供的不仅仅是解决一个问题的办法，而是解决一系列同类型问题的通用办法。解决办法是<strong>把判断标准提出来作为一个独立函数</strong>。</p>
<h3 id="面试题-21-2-调整数组奇前偶后，且保持相对位置"><a href="#面试题-21-2-调整数组奇前偶后，且保持相对位置" class="headerlink" title="面试题 21-2 调整数组奇前偶后，且保持相对位置"></a>面试题 21-2 调整数组奇前偶后，且保持相对位置</h3><p><strong>题目：</strong>在上题基础上，保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p> <strong>解法一：时间复杂度 $O(n^2)$</strong><br>每碰到一个偶数，就把这个数拿出来，并把位于这个数后面的所有数字往前挪一位，挪完后数组末尾有一个空位，这时把偶数放入这个空位。时间复杂度 $O(n^2)$，牛客网未通过 “段错误:您的程序发生段错误，可能是数组越界，堆栈溢出（比如，递归调用层数太多）等情况引起”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(unsigned long i = 0; i &lt; array.size(); i++)&#123;</span><br><span class="line">            if((array[i] &amp; 0x1) == 0)&#123;</span><br><span class="line">                int cur = array[i];</span><br><span class="line">                for(unsigned long j = i; j &lt; array.size()-1; j++)&#123;</span><br><span class="line">                    array[j] = array[j+1];</span><br><span class="line">                &#125;</span><br><span class="line">                array[-1] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：先数后存</strong><br>先遍历一遍统计奇数个数，得到排序后奇数和偶数的起始位置，再遍历一次存入。</p>
<h3 id="面试题-29：顺时针打印矩阵"><a href="#面试题-29：顺时针打印矩阵" class="headerlink" title="面试题 29：顺时针打印矩阵"></a>面试题 29：顺时针打印矩阵</h3><p><strong>题目：</strong>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p><strong>解题思路：</strong>由于是以从外圈到内圈的顺序依次打印的，所以我们可以把矩阵想象成若干个圈，用一个循环来打印矩阵，每次打印矩阵中的一个圈。</p>
<p>每一圈的开始坐标是 (0, 0)、(1, 1), …、第start + 1圈的开始坐标是 (start, start)，循环的终止条件是 2 x start &lt; 矩阵行数 且 2 x start &lt; 矩阵列数，因为第start + 1圈前，前start个圈已经用掉了 2 x start 行和列，只有行数和列数大于 2 x start 才说明存在第 start + 1 圈。</p>
<p>接着考虑如何打印每一圈，可以把打印一圈分为四步：从左到右打印一行、从上到下打印一行、从右到左打印一行和从下到上打印一行，每一步我们根据起始坐标和终止坐标用一个循环就能打印出一行或一列，每行打印的前提条件是：</p>
<ul>
<li>第一步：一定会打印，不需要前提；</li>
<li>第二步：如果只有一行，就不需要第二步了，也就是要求终止行号大于起始行号；</li>
<li>第三步：在满足第二步的前提下，至少有两列，即要求终止行号大于起始行号，且终止列号大于起始列号；</li>
<li>第四步：在满足第三步的条件下，终止行号比起始行好至少大2。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size(), columns = matrix[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(columns &gt; start * <span class="number">2</span> &amp;&amp; rows &gt; start * <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> endX = columns - <span class="number">1</span> - start;</span><br><span class="line">            <span class="keyword">int</span> endY = rows - <span class="number">1</span> - start;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= endX; i++) res.push_back(matrix[start][i]); <span class="comment">// 从左到右打印一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endY &amp;&amp; endY &gt; start; i++) res.push_back(matrix[i][endX]); <span class="comment">// 从上到下打印一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= start &amp;&amp; start &lt; endX &amp;&amp; start &lt; endY; i--) res.push_back(matrix[endY][i]); <span class="comment">// 从右往左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt;= start + <span class="number">1</span> &amp;&amp; start &lt; endY - <span class="number">1</span> &amp;&amp; start &lt; endX; i--) res.push_back(matrix[i][start]);<span class="comment">// 从下到上</span></span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题39：数组中出现次数超过一半的数字"><a href="#面试题39：数组中出现次数超过一半的数字" class="headerlink" title="面试题39：数组中出现次数超过一半的数字"></a>面试题39：数组中出现次数超过一半的数字</h3><p><strong>题目：</strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><strong>解题思路：</strong>用字典统计数字出现次数，当剩余数字个数+当前已统计的最多数字的个数 &lt;= 一半，则肯定不存在超过一半的数，直接返回0。</p>
<h3 id="面试题40：最小的-k-个数"><a href="#面试题40：最小的-k-个数" class="headerlink" title="面试题40：最小的 k 个数"></a>面试题40：最小的 k 个数</h3><p><strong>题目：</strong>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<p><strong>解法一：$O(nlogn)$ 排序选最小</strong><br><strong>解法二：$O(n)$  类似快排的思路</strong><br>基于数组的第 k 个数字来调整，比第 k 个数字小的所有数字都位于数组的左边，比第 k 个大的所有数字都位于数组的右边，这样位于数组左边的k 个数字就是最小的 k 个数字，这 k 个数字不一定是排序的。<br><strong>解法三：$O(nlogk)$ 最大堆适合海量数据</strong><br>创建一个大小为 k 的数据容器来存储最小的 k 个数字，接下来每次从输入的 n 个整数中读入一个数，如果容器中已有数字少于 k 个，则放入，如果已有 k 个，则找出 k 个树中的最大值，和插入值比较，如果插入值比当前最大值小，则插入。</p>
<p>对于<strong>海量数据不能一次性全部载入内存</strong>，这种方法可以从辅助存储空间每次读入一个数，适合 n 很大 且 k 较小的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span> || k &gt; input.size()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; k) q.push(input[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(input[i] &lt; q.top())&#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            res.push_back(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题：滑动窗口的最大值"><a href="#面试题：滑动窗口的最大值" class="headerlink" title="面试题：滑动窗口的最大值"></a>面试题：滑动窗口的最大值</h3><p><strong>题目：</strong>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<p><strong>解题思路：</strong>用一个temp数组，里面存放当前size大小窗口的最大值，和出现在最大值之后的次最大值，数组tmp最大等于size - 1，也就是分两步：</p>
<ul>
<li>判断当前的最大值是否过期；</li>
<li>将读入的数字和tmp中的每个元素从后向前比较，把小于读入数字的元素都丢掉，如果删除后temp的大小小于size-1，则将元素压入。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="literal">None</span> <span class="keyword">or</span> size &gt; len(num) <span class="keyword">or</span> size &lt; <span class="number">1</span>: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        temp = [<span class="number">0</span>]</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</span><br><span class="line">            <span class="keyword">if</span> i - temp[<span class="number">0</span>] &gt; size - <span class="number">1</span>:   <span class="comment"># 判断最大元素是否过期</span></span><br><span class="line">                temp.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> (len(temp) &gt; <span class="number">0</span> <span class="keyword">and</span> num[i] &gt;= num[temp[<span class="number">-1</span>]]):</span><br><span class="line">                temp.pop()</span><br><span class="line">            <span class="keyword">if</span> len(temp) &lt; size - <span class="number">1</span>:</span><br><span class="line">                temp.append(i)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> i &gt;= size - <span class="number">1</span>:</span><br><span class="line">                res.append(num[temp[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="面试题：矩阵中的路径"><a href="#面试题：矩阵中的路径" class="headerlink" title="面试题：矩阵中的路径"></a>面试题：矩阵中的路径</h3><p><strong>题目：</strong>设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bccced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p><strong>【回溯法】</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        flag = [<span class="literal">True</span>] * rows * cols</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span>(self.hasPathStartFromPoint(matrix, rows, cols, i, j, path, flag)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathStartFromPoint</span><span class="params">(self, matrix, rows, cols, i, j, path, flag)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        index = i * cols + j</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= rows <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= cols <span class="keyword">or</span> matrix[index]!= path[<span class="number">0</span>] <span class="keyword">or</span> flag[index] == <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        flag[index] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> (self.hasPathStartFromPoint(matrix, rows, cols, i<span class="number">-1</span>, j, path[<span class="number">1</span>:], flag) <span class="keyword">or</span>  </span><br><span class="line">            self.hasPathStartFromPoint(matrix, rows, cols, i, j<span class="number">-1</span>, path[<span class="number">1</span>:], flag) <span class="keyword">or</span></span><br><span class="line">            self.hasPathStartFromPoint(matrix, rows, cols, i+<span class="number">1</span>, j, path[<span class="number">1</span>:], flag) <span class="keyword">or</span></span><br><span class="line">            self.hasPathStartFromPoint(matrix, rows, cols, i, j+<span class="number">1</span>, path[<span class="number">1</span>:], flag)</span><br><span class="line">        ):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        flag[index] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<h3 id="面试题：机器人的运动范围"><a href="#面试题：机器人的运动范围" class="headerlink" title="面试题：机器人的运动范围"></a>面试题：机器人的运动范围</h3><p><strong>题目；</strong>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> rows &lt; <span class="number">1</span> <span class="keyword">or</span> cols &lt; <span class="number">1</span> <span class="keyword">or</span> threshold &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visited = [<span class="literal">False</span>] * rows * cols</span><br><span class="line">        <span class="keyword">return</span> self.movingCount_helper(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount_helper</span><span class="params">(self, threshold, rows, cols, curx, cury, visited)</span>:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> curx &lt; <span class="number">0</span> <span class="keyword">or</span> curx &gt;= cols <span class="keyword">or</span> cury &lt; <span class="number">0</span> <span class="keyword">or</span> cury &gt;= rows <span class="keyword">or</span> visited[cury * cols + curx]:</span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">        <span class="keyword">if</span> self.check(curx, cury, threshold):</span><br><span class="line">            visited[cury * cols + curx] = <span class="literal">True</span></span><br><span class="line">            cnt = <span class="number">1</span> + self.movingCount_helper(threshold, rows, cols, curx - <span class="number">1</span>, cury, visited) \</span><br><span class="line">                + self.movingCount_helper(threshold, rows, cols, curx + <span class="number">1</span>, cury, visited) \</span><br><span class="line">                + self.movingCount_helper(threshold, rows, cols, curx, cury - <span class="number">1</span>, visited) \</span><br><span class="line">                + self.movingCount_helper(threshold, rows, cols, curx, cury + <span class="number">1</span>, visited)</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, x, y, threshold)</span>:</span></span><br><span class="line">        res_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">            res_sum += x % <span class="number">10</span></span><br><span class="line">            x /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> y != <span class="number">0</span>:</span><br><span class="line">            res_sum += y % <span class="number">10</span></span><br><span class="line">            y /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res_sum &lt;= threshold</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C++ 中每个字符都以字符<code>\0</code> 作为结尾，这样我们能很方便地找到字符串的最后尾部。所以每个字符串都有一个额外字符的开销，使用时需要注意字符串的越界，比如把有10个字符的字符串复制到长度为10的字符数组会越界，因为字符串的实际长度为11个字节。</p>
<p>为了节省内存，C++把常量字符放到单独的内存区域，当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char str1[] = &quot;hello world&quot;;</span><br><span class="line">char str2[] = &quot;hello world&quot;;</span><br><span class="line"># str1 != str2, 两个字符串数组都分配了空间</span><br><span class="line"></span><br><span class="line">char * str3 = &quot;hello world&quot;;</span><br><span class="line">char * str4 = &quot;hello world&quot;;</span><br><span class="line"># str3 = str4，str3 和 str4 指向的是同一个地址。</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题4：替换空格"><a href="#面试题4：替换空格" class="headerlink" title="面试题4：替换空格"></a>面试题4：替换空格</h3><p><strong>题目</strong>：实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>解题思路</strong>：原来一个空格字符，替换后变成 ‘%’、’2’ 和 ‘0’ 这 3 个字符，如果是在原来的字符上做替换，就会覆盖修改在该字符串会面的内存；如果是创建新的字符串并在新的字符串上做替换，我们可以为自己分配足够多的内存。所以应该向面试官问清楚。假设面试官让我们在原来的字符串上做替换，并且保证输入的字符串后面有足够多的空余内存。</p>
<p><strong>解法一：从头扫描，没碰到一次就做一次替换</strong><br>时间复杂度为 $O(n^2)$ ：对每个空格字符，需要移动后面 $O(n)$ 个字符。</p>
<p><strong>解法二：从前往后记录，从后往前替换</strong><br>时间复杂度为 $O(n)$ ：解法一<strong>很多字符都移动了很多次，如果改为从后向前替换可以减少移动次数。</strong></p>
<p>先遍历一遍字符串，统计出空格的总数，就可以得到替换之后的字符串的总长度，即 替换后长度 = 原长度 + 2 x 空格数目。从字符串末尾开始替换，首先准备两个指针 $P1$ 和 $P2$ ， 分别指向原始字符串末尾和替换之后空白区的最末尾空白位置。接下来向前移动 $P1$ ，逐个复制到 $P2$ ，碰到空格则在 $P2$ 前插入字符串 “%20” ， $P2$ 向前移动3格。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">nullptr</span> &amp;&amp; length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> originalLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberOfBlack = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            originalLength += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>) numberOfBlack += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> newLength = originalLength + <span class="number">2</span> * numberOfBlack;</span><br><span class="line">        <span class="keyword">if</span>(newLength &gt; length) <span class="keyword">return</span>;   <span class="comment">// 剩余空间放不下</span></span><br><span class="line">        <span class="keyword">int</span> indexOfOriginal = originalLength;</span><br><span class="line">        <span class="keyword">int</span> indexOfNew = newLength;</span><br><span class="line">        <span class="keyword">while</span>(indexOfOriginal &gt;= <span class="number">0</span> &amp;&amp; indexOfNew &gt; indexOfOriginal)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[indexOfOriginal] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[indexOfNew --] = <span class="string">'0'</span>;</span><br><span class="line">                str[indexOfNew --] = <span class="string">'2'</span>;</span><br><span class="line">                str[indexOfNew --] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str[indexOfNew --] = str[indexOfOriginal];</span><br><span class="line">            &#125;</span><br><span class="line">            -- indexOfOriginal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址及临时变量等。通常栈是一个不考虑排序的数据结构，需要 $O(n)$ 的时间才能找到栈中最大或者最小的元素。如果想在 $O(1)$ 的时间内得到栈的最大或者最小值，我们需要对栈做特殊设计。</p>
<p>队列是先进先出，在树的广度优先遍历算法中，在遍历某一层树的结点上，把结点的子结点放到一个队列里，以备下一层结点的遍历。</p>
<h3 id="面试题7：用两个栈实现队列"><a href="#面试题7：用两个栈实现队列" class="headerlink" title="面试题7：用两个栈实现队列"></a>面试题7：用两个栈实现队列</h3><p><strong>题目：</strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p><strong>解题思路：</strong>要删除一个元素，如果stack2为空，则把stack1中的元素逐个弹出压入stack2中，由于先进入队列的元素被压到stack1的底端，经过弹出和压入之后就处于stack2的顶端了，可以直接弹出；若stack2不为空，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> data = stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> head = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>用两个队列实现一个栈</strong><br>弹出元素：从一个queue依次删除元素并放到另一个空queue中，直到最后一个元素，将其弹出。<br>压入元素：直接插入到有元素的那个队列尾部。</p>
<h3 id="面试题-30：包含min的栈"><a href="#面试题-30：包含min的栈" class="headerlink" title="面试题 30：包含min的栈"></a>面试题 30：包含min的栈</h3><p><strong>题目：</strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为$O(1)$）。定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为$O(1)$）。</p>
<p><strong>解题思路：</strong>把每次的最小元素都用一个辅助栈保存，就能保证辅助栈的栈顶一直都是最小元素，当最小元素从数据栈内被弹出之后，同时弹出辅助栈的栈顶元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty()) s2.push(value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s1.top() &lt;= s2.top()) s2.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.top() == s2.top()) s2.pop();</span><br><span class="line">        s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题-31：栈的压入、弹出序列"><a href="#面试题-31：栈的压入、弹出序列" class="headerlink" title="面试题 31：栈的压入、弹出序列"></a>面试题 31：栈的压入、弹出序列</h3><p><strong>题目：</strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）。<br><strong>解题思路：</strong>如果下一个弹出的数字刚好是栈顶数字，那么直接弹出；如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止；如果所有数字都压入栈后依然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.size() == <span class="number">0</span> <span class="keyword">or</span> popV.size() == <span class="number">0</span>) <span class="keyword">return</span> false;</span><br><span class="line">        stack&lt;int&gt; helper;</span><br><span class="line">        int push_cur = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(unsigned long i = <span class="number">0</span>; i &lt; popV.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(helper.empty() || helper.top() != popV[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(unsigned long j = push_cur+<span class="number">1</span>; j &lt; pushV.size(); j++)&#123;</span><br><span class="line">                    helper.push(pushV[j]);</span><br><span class="line">                    <span class="keyword">if</span>(pushV[j] == popV[i])&#123;</span><br><span class="line">                        push_cur = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(helper.top() != popV[i]) <span class="keyword">return</span> false;</span><br><span class="line">                <span class="keyword">else</span> helper.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                helper.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(helper.empty() &amp;&amp; pushV.size() == popV.size()) <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>顺序查找、二分查找、哈希表查找和二叉排序树查找。</p>
<blockquote>
<p>如果面试题是要求在排序的数组（或部分排序的数组）中查找一个数字或者统计某个数字出现的次数，我们都可以尝试用二分查找算法。</p>
</blockquote>
<p><strong>哈希表</strong> 的主要优点是能够在 $O(1)$ 的时间查找元素，缺点是需要额外的空间实现哈希表。</p>
<p><strong>二叉排序树查找</strong> 对应的数据结构是二叉搜索树。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。从额外空间消耗、平均时间复杂度和最差时间复杂度等方面比较。</p>
<p><strong>快速排序</strong><br>总体的平均效率是最好的，但在数组本身已经有序，而每一轮排序的时候都是以最后一个数字作为比较的标准，此时快速排序的效率只有 $O(n^2)$ . </p>
<p>面试时一定要问清楚排序应用的环境时什么，有哪些约束条件：</p>
<ul>
<li>对什么数字进行排序，有多少个数字；</li>
<li>数字的大小是否在一个较小的范围之内，如年龄；</li>
<li>是否可以使用辅助空间。</li>
</ul>
<p><strong>对年龄排序：</strong><br>年龄有一个范围，可以先统计每个年龄出现了多少次。</p>
<h3 id="面试题8：旋转数组的最小数字"><a href="#面试题8：旋转数组的最小数字" class="headerlink" title="面试题8：旋转数组的最小数字"></a>面试题8：旋转数组的最小数字</h3><p><strong>题目：</strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p><strong>测试用例：</strong></p>
<ul>
<li>边界值测试，如输入是把排序数组前0个搬到后面，及排序数组本身、只包含一个数字的数组；</li>
<li>有重复数字，如(1, 0, 1, 1, 1)，只能用顺序查找的方法。</li>
</ul>
<p><strong>解题思路；</strong>旋转之后的数组可以分为两个排序的字数组，而且前面的子数组的元素都大于或等于后面子数组的元素，最小的元素刚好是这两个数组的分界线。</p>
<p>因为数组在一定程度上是排序的，所以可以用二分法。用两个指针start 和 end分别指向数组的第一个元素和最后一个元素，找到数组中间的元素mid，如果mid在前面的递增子数组中，那么<strong>它应该大于或等于start（特例：把排序数组前0个搬到后面，及排序数组本身！）</strong>，此时最小的应该在mid后面，因此让start = mid 缩小范围；mid &lt; start 则 让end = mid；这样最终他们会指向两个相邻元素，start将指向前面子数组的最后一个元素，end会指向后面子组的第一个元素，而end指向的刚好是最小的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = rotateArray.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(rotateArray[start] &gt;= rotateArray[end])&#123;</span><br><span class="line">            <span class="keyword">if</span>(end - start == <span class="number">1</span>)&#123;   <span class="comment">// 循环终止条件，start和end相邻</span></span><br><span class="line">                mid = end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[start] == rotateArray[end] </span><br><span class="line">               &amp;&amp; rotateArray[start] == rotateArray[mid])</span><br><span class="line">                <span class="keyword">return</span> MinInOrder(rotateArray, start, end);   <span class="comment">// 用顺序查找</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt;= rotateArray[start])&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt;= rotateArray[end])&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = rotateArray[start];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result &gt; rotateArray[i]) result = rotateArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="递归和循环"><a href="#递归和循环" class="headerlink" title="递归和循环"></a>递归和循环</h2><p><strong>递归</strong>是在函数的内部调用这个函数自身，<strong>循环</strong>是通过设置计算的初始值及终止条件，在一个范围内重复运算。</p>
<p>递归的本质是把一个问题分解成两个或多个小问题，代码更简洁且容易实现，但是消耗时间和空间：</p>
<ul>
<li>每次函数调用都需要在内存栈中分配空间以保存参数、返回地址和临时变量；而<strong>每个进程的栈的容量是有限的，当递归调用的层级太多时就会导致调用栈溢出</strong>。</li>
<li>往栈里压入数据和弹出数据都需要时间；</li>
<li>有可能很多计算都是重复的，从而对性能有很大的负面影响。</li>
</ul>
<h3 id="面试题9：斐波那契数列"><a href="#面试题9：斐波那契数列" class="headerlink" title="面试题9：斐波那契数列"></a>面试题9：斐波那契数列</h3><p><strong>题目：</strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）n&lt;=39</p>
<p><strong>解法一：递归法</strong><br>牛客网无法通过：内存超限，使用了超过限制的内存<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：从下往上循环计算</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fib1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fib2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fib = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            fib = fib1 + fib2;</span><br><span class="line">            fib1 = fib2;</span><br><span class="line">            fib2 = fib;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法三：数学公式法</strong><br>转换成求矩阵的乘方，基于递归可以用 $O(logn)$ 求得。</p>
<p><strong>扩展题目：青蛙跳台阶1</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级，求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> jump0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> jump1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> jump = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= number; i++)&#123;</span><br><span class="line">            jump = jump0 + jump1;</span><br><span class="line">            jump0 = jump1;</span><br><span class="line">            jump1 = jump;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jump;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>扩展题目：青蛙跳台阶2</strong></p>
<p><strong>扩展题目：矩阵覆盖</strong><br>用2x1的小矩形横着或者竖着去覆盖更大的矩形，问用8个2x1的小矩形无重复地覆盖一个2x8的大矩形，总共有多少种方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cover1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cover2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cover = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= number; i++)&#123;</span><br><span class="line">            cover = cover1 + cover2;</span><br><span class="line">            cover1 = cover2;</span><br><span class="line">            cover2 = cover;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cover;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题16：数值的整数次方"><a href="#面试题16：数值的整数次方" class="headerlink" title="面试题16：数值的整数次方"></a>面试题16：数值的整数次方</h3><p><strong>题目：</strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br><strong>解题思路：</strong>16次方等于8次方的平方，用递归法实现。<strong>注意考虑情况（1）输入的指数为零或负数；（2）底数是0且指数是负数。</strong><br><strong>优化：</strong>（1）用位与运算代替求余；（2）用右移运算符代替除以2。</p>
<p><strong>解法一：递归法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(exponent);  <span class="comment">//abs(INT_MIN)仍为负数！！</span></span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">            base = <span class="number">1</span> / base;</span><br><span class="line">        <span class="keyword">return</span> (un &amp; <span class="number">0x1</span> == <span class="number">0</span>) ? Power(base * base, un&gt;&gt;<span class="number">1</span>) : base * Power(base * base, un&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：非递归法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(exponent);  <span class="comment">//abs(INT_MIN)仍为负数！！</span></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">            base = <span class="number">1</span> / base;</span><br><span class="line">        <span class="keyword">while</span>(un &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(un &amp; <span class="number">0x1</span> == <span class="number">1</span>) res *= base;</span><br><span class="line">            base *= base;</span><br><span class="line">            un = un &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题38：字符串的排列"><a href="#面试题38：字符串的排列" class="headerlink" title="面试题38：字符串的排列"></a>面试题38：字符串的排列</h3><p><strong>题目：</strong>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p><strong>解法一：递归</strong><br>求整个字符串的排列，可以看作两步：第一步求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换；第二步固定一个字符，求后面所有字符的排序，这时候仍把后面的所有字符分成两部分…<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">""</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(res, <span class="number">0</span>, str);</span><br><span class="line">        std::sort(res.begin(), res.end());   // 按字典序打印</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(vector&lt;string&gt; &amp;res, unsigned long start, string &amp;str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == str.size())  // 递归终止条件</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(unsigned long i = start; i &lt; str.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[start] == str[i] &amp;&amp; start != i) <span class="keyword">continue</span>; // 防止重复出现</span><br><span class="line">                std:swap(str[start], str[i]);</span><br><span class="line">                helper(res, start+<span class="number">1</span>, str);</span><br><span class="line">                std::swap(str[start], str[i]);      // 本次递归完成后还原</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：迭代</strong><br>对已排好的n-1个字符，如果来了第n个字符，则这个字符可在n-1个字符上有n个位置插入位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        if(str == &quot;&quot;) return res;</span><br><span class="line">        res.push_back(&quot;&quot;);</span><br><span class="line">        for(int i = 0; i &lt; str.size(); i++)&#123;</span><br><span class="line">            vector&lt;string&gt; res_tmp(std::move(res));  // move 拷贝临时对象</span><br><span class="line">            for(int j = 0; j &lt; res_tmp.size(); j++)&#123; // 将新来的n插入到在已排好的res不同位置上</span><br><span class="line">                for(int k = 0; k &lt;= res_tmp[0].size(); k++)&#123;</span><br><span class="line">                    if(k &lt; res_tmp[0].size() &amp;&amp; str[i] == res_tmp[j][k]) continue; //防止重复，要插入的数字和当前位一样</span><br><span class="line">                    string str_tmp = res_tmp[j];</span><br><span class="line">                    str_tmp.insert(k, 1, str[i]);</span><br><span class="line">                    res.push_back(str_tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::sort(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote>
<p>世界上有10种人，一种是知道二进制的，一种是不知道二进制的。</p>
</blockquote>
<p>位运算共有与、或、异或、左移和右移 5 种位运算：</p>
<ul>
<li>左移：m&lt;&lt;n 把m左移n位，左移n位的时候，右边补n个0，最左边的n位将被丢弃。</li>
<li>右移：m&gt;&gt;n 把m右移n位，左边用0填补，右边n位丢弃。右移时处理最左边位要负责一点，如果无符号则用0填补最左边n位，<strong>对有符号数值，则用数字的符号为填补最左边的n位，也就是说如果数字原先是正数，则右移之后在最左边补n个0，如果数字原先是负数，则右移之后在最左边补n个1.</strong></li>
</ul>
<h3 id="面试题10：二进制中1的个数"><a href="#面试题10：二进制中1的个数" class="headerlink" title="面试题10：二进制中1的个数"></a>面试题10：二进制中1的个数</h3><p><strong>题目：</strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p><strong>引起死循环的解法：</strong>先判断最右边一位是不是1，接着把输入的整数右移一位，再判断是不是1，…把整数除以2 等价于把整数右移一位，但除法的效率比移位运算低得多，实际编程中应尽可能地用移位运算符代替乘除法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)&#123;</span><br><span class="line">             <span class="keyword">if</span>(n &amp; <span class="number">1</span>) count += <span class="number">1</span>;</span><br><span class="line">             n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>如果输入一个负数，上面的解法会进入死循环</strong>，因为左边补的永远都是111111…所以正确的解题思路我们可以不右移输入的数字i，首先把 i 和 1 做与运算，判断 i 的最低位是不是 1，接着把 1 左移，再和 i 做与运算，就能判断次低位是不是 1，…，即解法一。</p>
<p><strong>解法一：左移1相与</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(i)&#123;</span><br><span class="line">             <span class="keyword">if</span>(n &amp; i) count += <span class="number">1</span>;</span><br><span class="line">             i = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：求 $N \&amp; (N-1)$</strong><br>对一个整数 $N$ ，求 <strong>$N\&amp;(N-1)$ 相当于把最右边的 1 变成0</strong> 。因为 $N-1$ 会把最右边的1变成0，如果它右边还有0的话，所有0都变成1，而它左边所有位都保持不变。所以把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。一个整数的二进制有多少个1，就能进行多少次这样的操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)&#123;</span><br><span class="line">             count += <span class="number">1</span>;</span><br><span class="line">             n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="面试题43：整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#面试题43：整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="面试题43：整数中1出现的次数（从1到n整数中1出现的次数）"></a>面试题43：整数中1出现的次数（从1到n整数中1出现的次数）</h3><p><strong>题目：</strong>输入一个整数 n，求 1～n 这 n 个整数的十进制表示中 1 出现的次数。例如，输入12， 1～12 中包含 1 的数字有1、10、11、12，1一共出现了5次。</p>
<p><strong>解法一：</strong>设定1、10、100、1000…为中间点，分别考虑个位、十位、百分位…有多少个包含1的树进行分析。根据设定的位置 i 对 n 进行分割，可以分为两部分，高位为 $a=n/i$，低位为 $b = n\%i$：</p>
<ul>
<li>当 $i=100$时，若百分位对应的数字大于等于2，设$n = 21345$，那么 $a=213，b=45$，此时百位为1的次数有$a/10+1 = 22$ 次，22次里每次都包含0到99这100个连续的数，那么百位为1的数一共有 $22\times100$次。</li>
<li>若百位对应的数字是 1，设$n = 21145$，那么 $a=211，b=45$，此时要分两部分考虑：<br>（1）对$a/10 = 21$ 次百位为1（0到20），每次都包含0到99这100个连续的数，那么百位为1的数一共有 $21\times100$次。<br>（2）对最高两位为21时，百位为1，此时百位所包含的数共有0到45个，即b+1个。</li>
<li>若百位对应的数位0，设$n = 21045$，那么 $a=210，b=45$，那么百位为1的次数为0到20，共21次，即$a/10$， 每次都包含0到99这100个连续的数，那么百位为1的数一共有 $21\times100$次。</li>
</ul>
<p>综上所述，百位对应的数字为 0 或者大于等于2时，有(a+8)/10 次包含0到99个连续数，之所以补8，是因为当百位为0，则a/10 == (a+8)/10，当百位&gt;=2，补8后进位 = (a/10+1)；当百位对应的数是1时，需要增加未满100的数b+1个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = n / i, b = n % i;</span><br><span class="line">            count = count + (a+<span class="number">8</span>) / <span class="number">10</span> * i + (a % <span class="number">10</span> == <span class="number">1</span>) * (b + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于精度原因，不能用等号判断两个小数是否相等 (<code>double d1,d2; if(d1 == d2){...}</code>)</p>
</blockquote>
<h1 id="高质量代码"><a href="#高质量代码" class="headerlink" title="高质量代码"></a>高质量代码</h1><p>最好用完整的英文单词来命名变量和函数；<br>减慢写字的速度，尽量把每个字都写清楚，通常面试代码量不会超过50行。<br>关注对输入参数的检查、处理错误和异常的方式、命名方式等。</p>
<h3 id="代码完整性"><a href="#代码完整性" class="headerlink" title="代码完整性"></a>代码完整性</h3><ul>
<li>（1）<strong>功能测试</strong>：尽量突破常规思维的限制，“打印从1到最大的n位数”，最大的n位数有多大呢，是否连long long都表示不了呢，如果题目要求的是任意大，那这道题就是<strong>大数问题</strong>，需要特殊的数据结构来表示数字，比如字符串或数组，确保不会溢出；</li>
<li>（2）<strong>边界测试</strong>：递归终止边界，“字符串转换成整数”应该确保能正确转换的最大正整数和最小负整数；</li>
<li>（3）<strong>负面测试</strong>：非法输入。</li>
</ul>
<h3 id="错误处理方式"><a href="#错误处理方式" class="headerlink" title="错误处理方式"></a>错误处理方式</h3><ul>
<li>（1）<strong>返回值</strong>：优点是和系统API一致，缺点是不能方便地使用计算结果；</li>
<li>（2）<strong>全局变量</strong>：能够方便地使用计算结果，缺点是用户可能会忘记检查全局变量；</li>
<li>（3）<strong>异常</strong>：优点是可以为不同的出错原因定义不同异常类型，逻辑清晰明了，缺点是有些语言不支持异常，抛出异常时对性能有负面影响。</li>
</ul>
<p>随时能正确完整地写出带脉<br>二分查找<br>归并排序<br>快速排序</p>
<h3 id="面试题39：数组中出现次数超过一半的数字-1"><a href="#面试题39：数组中出现次数超过一半的数字-1" class="headerlink" title="面试题39：数组中出现次数超过一半的数字"></a>面试题39：数组中出现次数超过一半的数字</h3><p><strong>题目：</strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><strong>解题思路：</strong>用字典统计数字出现次数，当剩余数字个数+当前已统计的最多数字的个数 &lt;= 一半，则肯定不存在超过一半的数，直接返回0。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        max_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(numbers):</span><br><span class="line">            <span class="keyword">if</span> len(numbers) - i + max_num &lt;= len(numbers) / <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> dict: dict[num]= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: dict[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dict[num] &gt; max_num: max_num = dict[num]</span><br><span class="line">            <span class="keyword">if</span> dict[num] &gt; len(numbers)/ <span class="number">2</span>: <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题40：最小的-k-个数-1"><a href="#面试题40：最小的-k-个数-1" class="headerlink" title="面试题40：最小的 k 个数"></a>面试题40：最小的 k 个数</h3><p><strong>题目：</strong>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<p><strong>解法一：$O(nlogn)$ 排序选最小</strong><br><strong>解法二：$O(n)$  类似快排的思路</strong><br>基于数组的第 k 个数字来调整，比第 k 个数字小的所有数字都位于数组的左边，比第 k 个大的所有数字都位于数组的右边，这样位于数组左边的k 个数字就是最小的 k 个数字，这 k 个数字不一定是排序的。<br><strong>解法三：$O(nlogk)$ 适合海量数据</strong><br>创建一个大小为 k 的数据容器来存储最小的 k 个数字，接下来每次从输入的 n 个整数中读入一个数，如果容器中已有数字少于 k 个，则放入，如果已有 k 个，则找出 k 个树中的最大值，和插入值比较，如果插入值比当前最大值小，则插入。</p>
<p>对于<strong>海量数据不能一次性全部载入内存</strong>，这种方法可以从辅助存储空间每次读入一个数，适合 n 很大 且 k 较小的问题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(tinput) &lt; k <span class="keyword">or</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tinput:</span><br><span class="line">            <span class="keyword">if</span> len(res) &lt; k:</span><br><span class="line">                res.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_max = max(res)</span><br><span class="line">                <span class="keyword">if</span> cur_max &gt; i:</span><br><span class="line">                    res[res.index(cur_max)] = i </span><br><span class="line">        res.sort()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题-42：连续子数组的最大和"><a href="#面试题-42：连续子数组的最大和" class="headerlink" title="面试题 42：连续子数组的最大和"></a>面试题 42：连续子数组的最大和</h3><p><strong>题目：</strong>输入一个整型数组，数组里有正数也有负数，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值，要求时间复杂度为 $O(n)$<br><strong>解题思路：动态规划法</strong>，$dp[n]$ 代表以第 $n$ 个数字结尾的子数组的连续最大和。 </p>
<script type="math/tex; mode=display">
dp[n] =\left\{
\begin{aligned}
&array[n]&  &i = 0 \ 或\ dp[i-1] \le 0& \\
&dp[n-1] + array[n] & &i \ne dp[i-1] \gt 0& \\
\end{aligned}
\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(array) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = [float(<span class="string">'-inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(array))] <span class="comment"># 初始化为-inf</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> res[i - <span class="number">1</span>] &lt; <span class="number">0</span>: </span><br><span class="line">                res[i] = array[i]</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                res[i] = res[i - <span class="number">1</span>] + array[i]</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br></pre></td></tr></table></figure>
<h3 id="面试题43：整数中1出现的次数（从1到n整数中1出现的次数）-1"><a href="#面试题43：整数中1出现的次数（从1到n整数中1出现的次数）-1" class="headerlink" title="面试题43：整数中1出现的次数（从1到n整数中1出现的次数）"></a>面试题43：整数中1出现的次数（从1到n整数中1出现的次数）</h3><p><strong>题目：</strong>输入一个整数 n，求 1～n 这 n 个整数的十进制表示中 1 出现的次数。例如，输入12， 1～12 中包含 1 的数字有1、10、11、12，1一共出现了5次。</p>
<p><strong>解法一：</strong>设定1、10、100、1000…为中间点，分别考虑个位、十位、百分位…有多少个包含1的树进行分析。根据设定的位置 i 对 n 进行分割，可以分为两部分，高位为 $a=n/i$，低位为 $b = n\%i$：</p>
<ul>
<li>当 $i=100$时，若百分位对应的数字大于等于2，设$n = 21345$，那么 $a=213，b=45$，此时百位为1的次数有$a/10+1 = 22$ 次，22次里每次都包含0到99这100个连续的数，那么百位为1的数一共有 $22\times100$次。</li>
<li>若百位对应的数字是 1，设$n = 21145$，那么 $a=211，b=45$，此时要分两部分考虑：<br>（1）对$a/10 = 21$ 次百位为1（0到20），每次都包含0到99这100个连续的数，那么百位为1的数一共有 $21\times100$次。<br>（2）对最高两位为21时，百位为1，此时百位所包含的数共有0到45个，即b+1个。</li>
<li>若百位对应的数位0，设$n = 21045$，那么 $a=210，b=45$，那么百位为1的次数为0到20，共21次，即$a/10$， 每次都包含0到99这100个连续的数，那么百位为1的数一共有 $21\times100$次。</li>
</ul>
<p>综上所述，百位对应的数字为 0 或者大于等于2时，有(a+8)/10 次包含0到99个连续数，之所以补8，是因为当百位为0，则a/10 == (a+8)/10，当百位&gt;=2，补8后进位 = (a/10+1)；当百位对应的数是1时，需要增加未满100的数b+1个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= n):</span><br><span class="line">            a = n / i</span><br><span class="line">            b = n % i</span><br><span class="line">            count = count + int((a+<span class="number">8</span>)/<span class="number">10</span> * i) + (a%<span class="number">10</span>==<span class="number">1</span>) * int(b+<span class="number">1</span>)</span><br><span class="line">            i *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="面试题45：把数组排成最小的数"><a href="#面试题45：把数组排成最小的数" class="headerlink" title="面试题45：把数组排成最小的数"></a>面试题45：把数组排成最小的数</h3><p><strong>题目：</strong>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p><strong>解题思路：</strong>把两个int型的整数拼接起来得到的数字可能会超过int型数字能够表达的范围，为了防止组成的数溢出，通过将数字转换为字符串解决大数问题。A、B两个数前后位置根据AB 和 BA 的大小决定，如果AB &gt; BA，则B在A前。最后利用快排的思路对列表进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) &lt; <span class="number">1</span>: <span class="keyword">return</span> numbers</span><br><span class="line">        left = self.helper([i <span class="keyword">for</span> i <span class="keyword">in</span> numbers[<span class="number">1</span>:] <span class="keyword">if</span> int(i+numbers[<span class="number">0</span>]) &lt; int(numbers[<span class="number">0</span>]+i)])</span><br><span class="line">        right = self.helper([i <span class="keyword">for</span> i <span class="keyword">in</span> numbers[<span class="number">1</span>:] <span class="keyword">if</span> int(i+numbers[<span class="number">0</span>]) &gt;= int(numbers[<span class="number">0</span>]+i)])</span><br><span class="line">        <span class="keyword">return</span> left + [numbers[<span class="number">0</span>]] + right</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        numbers = [str(num) <span class="keyword">for</span> num <span class="keyword">in</span> numbers]</span><br><span class="line">        <span class="keyword">if</span> len(numbers) &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="string">''</span>.join(numbers)</span><br><span class="line">        res = self.helper(numbers)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
<h3 id="面试题49：丑数"><a href="#面试题49：丑数" class="headerlink" title="面试题49：丑数"></a>面试题49：丑数</h3><p><strong>题目：</strong>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p><strong>解法一：逐个判断每个数是不是丑数</strong><br>如果一个数能被2整数，就连续除以2，如果能被3整除，就连续除以3，如果能被5整除，就连续除以5，如果最后得到的是1，这个数就是丑数，否则不是。</p>
<p><strong>解法二：用数组保存已找到的丑数，用空间换时间</strong><br>解法一只所以效率低，很大程度上是因为不管一个数是不是丑数，我们都要对它进行计算。可以创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或5得到的。<br>关键在于如何确保数组里面的丑数是排好序的，假设数组里已排好序的最大的丑数是M，接下来加入的丑数肯定是前面某一个丑数乘以2、3 或 5得到的，所以把数组里的数依次乘以2，找到第一个大于$M$的结果$M_2$，同时把已有的每个丑数乘以3 和 5 得到 $M_3$, $M_5$，则下一个加入的就是 $M_2$， $M_3$ 和 $M_5$ 中最小的那个。<br>记录下$M_2 = T_2 \times 2$， $M_3 = T_3 \times 3$ 和 $M_5 = T_5 \times 5$ 对应的$T_2$， $T_3$ 和 $T_5$ ，不需要再重复和 $T_2$， $T_3$ 和 $T_5$ 之前的数相乘。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sorted_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">6</span>: <span class="keyword">return</span> sorted_list[index - <span class="number">1</span>]</span><br><span class="line">        T2 = T3 = T5 = <span class="number">0</span></span><br><span class="line">        M2 = M3 = M5 = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> len(sorted_list) &lt; index:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(T2, len(sorted_list)):</span><br><span class="line">                <span class="keyword">if</span> sorted_list[i] * <span class="number">2</span> &gt; sorted_list[<span class="number">-1</span>]:</span><br><span class="line">                    T2 = i</span><br><span class="line">                    M2 = sorted_list[i] * <span class="number">2</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(T3, len(sorted_list)):</span><br><span class="line">                <span class="keyword">if</span> sorted_list[i] * <span class="number">3</span> &gt; sorted_list[<span class="number">-1</span>]:</span><br><span class="line">                    T3 = i</span><br><span class="line">                    M3 = sorted_list[i] * <span class="number">3</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(T5, len(sorted_list)):</span><br><span class="line">                <span class="keyword">if</span> sorted_list[i] * <span class="number">5</span> &gt; sorted_list[<span class="number">-1</span>]:</span><br><span class="line">                    T5 = i</span><br><span class="line">                    M5 = sorted_list[i] * <span class="number">5</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            sorted_list.append(min([M2, M3, M5]))</span><br><span class="line">        <span class="keyword">return</span> sorted_list[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="面试题50：第一个只出现一次的字符"><a href="#面试题50：第一个只出现一次的字符" class="headerlink" title="面试题50：第一个只出现一次的字符"></a>面试题50：第一个只出现一次的字符</h3><p><strong>题目：</strong>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.<br><strong>解题思路：</strong>两次遍历字符串，第一次统计用哈希表统计每个字符出现的次数，第二次遍历找只出现一次的字符。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>: <span class="keyword">return</span> s</span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            dict[c] = dict.get(c, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> dict[c] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="面试题51：数组中的逆序对"><a href="#面试题51：数组中的逆序对" class="headerlink" title="面试题51：数组中的逆序对"></a>面试题51：数组中的逆序对</h3><p><strong>题目：</strong>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p><strong>解题思路：</strong>先把数组分割成子数组，统计出子数组内部的逆序对数目，然后再统计出两个相邻子数组之间的逆序对的数目，并对数组进行排序。</p>
<p>两个相邻子数组的统计方式是，先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字，如果第一个子数组中的数字大于第二个子数组的数字，则构成逆序对，且逆序对的数目等于第二个子数组中剩余数字的个数；每次比较时，都把较大的数字从后往前复制到一个辅助数组，确保辅助数组中的数字是递增排序的；在把较大的数字复制到辅助数组后，把对应的指针向前移动一位，继续下一轮比较。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(data) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        _, s = self.MergeSort(data)</span><br><span class="line">        <span class="keyword">return</span> s%<span class="number">1000000007</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        n = len(data)     </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:<span class="keyword">return</span> data, <span class="number">0</span>   <span class="comment"># 1. 终止条件</span></span><br><span class="line">        p1, p2 = data[:n//<span class="number">2</span>], data[n//<span class="number">2</span>:]    <span class="comment"># 2. 划分</span></span><br><span class="line">        sorted_p1, s1 = self.MergeSort(p1)   <span class="comment"># 3. 每块送入递归</span></span><br><span class="line">        sorted_p2, s2 = self.MergeSort(p2)</span><br><span class="line">        s, sorted_tmp = <span class="number">0</span>, sorted_p1 + sorted_p2    <span class="comment"># 合并两部分结果</span></span><br><span class="line">        p, q, len1, len_all = <span class="number">0</span>, sorted_tmp.index(sorted_p2[<span class="number">0</span>]), len(sorted_p1), len(sorted_tmp)</span><br><span class="line">        <span class="keyword">while</span> p &lt; len1 <span class="keyword">and</span> q &lt; len_all:</span><br><span class="line">            <span class="keyword">while</span> p &lt; len1:</span><br><span class="line">                <span class="keyword">if</span> sorted_tmp[q] &lt; sorted_tmp[p]:</span><br><span class="line">                    s += len1 - p</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            q += <span class="number">1</span></span><br><span class="line">        l = []</span><br><span class="line">        p, q = <span class="number">0</span>, sorted_tmp.index(sorted_p2[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span> p &lt; len1 <span class="keyword">and</span> q &lt; len_all:</span><br><span class="line">            <span class="keyword">if</span> sorted_tmp[p] &lt; sorted_tmp[q]:</span><br><span class="line">                l.append(sorted_tmp[p])</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l.append(sorted_tmp[q])</span><br><span class="line">                q += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p == len1: l+= sorted_tmp[q:]</span><br><span class="line">        <span class="keyword">if</span> q == len_all: l += sorted_p1[p:]</span><br><span class="line">        <span class="keyword">return</span> l, s + s1 + s2</span><br></pre></td></tr></table></figure>
<h3 id="面试题52：两个链表的第一个公共结点"><a href="#面试题52：两个链表的第一个公共结点" class="headerlink" title="面试题52：两个链表的第一个公共结点"></a>面试题52：两个链表的第一个公共结点</h3><p><strong>题目：</strong>输入两个链表，找出它们的第一个公共结点。<br><strong>解法一：栈</strong><br>如果两个链表有公共节点，那么公共节点出现在两个链表的尾部，如果从两个链表的尾部开始往前比较，最后一个相同的节点就是要找的节点。对单向链表只能从前往后遍历，比较想要从后往前，“后进先出” 是栈的特点，所以用栈来解决，</p>
<p>分别把两个链表的节点放入两个栈中，两个链表的尾节点位于栈顶，接下来比较栈顶节点是否相同，如果相同则弹出，直到找到最后一个相同的节点。</p>
<p>空间复杂度 $O(m+n)$，时间复杂度 $O(m+n)$</p>
<p><strong>解法二：先后遍历</strong><br>只所以用栈，是想遍历时同时到达尾节点，当两个链表长度不同时，<br>首先遍历两个链表得到它们的长度，就可以知道长链表比短链表长多少，在第二次遍历的时候在长链表上先走若干步，接着同时在两个链表上遍历，找到第一个相同的节点就是它们的公共节点。<br>时间复杂度时$O(n+m)$，不需要辅助栈。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 == <span class="literal">None</span> <span class="keyword">or</span> pHead2 == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        len1 = len2 = <span class="number">0</span></span><br><span class="line">        cur1, cur2 = pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> cur1 != <span class="literal">None</span>:</span><br><span class="line">            len1 += <span class="number">1</span></span><br><span class="line">            cur1 = cur1.next</span><br><span class="line">        <span class="keyword">while</span> cur2 != <span class="literal">None</span>:</span><br><span class="line">            len2 += <span class="number">1</span></span><br><span class="line">            cur2 = cur2.next</span><br><span class="line">        cur1, cur2 = pHead1, pHead2   </span><br><span class="line">        <span class="keyword">if</span> len1 != len2:</span><br><span class="line">            <span class="keyword">while</span> len1 - len2 &gt; <span class="number">0</span>:</span><br><span class="line">                cur1 = cur1.next</span><br><span class="line">                len1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> len2 - len1 &gt; <span class="number">0</span>:</span><br><span class="line">                cur2 = cur2.next</span><br><span class="line">                len2 -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">while</span> cur1 != <span class="literal">None</span> <span class="keyword">and</span> cur1.val != cur2.val:</span><br><span class="line">            cur1, cur2 = cur1.next, cur2.next</span><br><span class="line">        <span class="keyword">if</span> cur1 != <span class="literal">None</span>: <span class="keyword">return</span> cur1</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="面试题-数字在排序数组中出现的次数"><a href="#面试题-数字在排序数组中出现的次数" class="headerlink" title="面试题 数字在排序数组中出现的次数"></a>面试题 数字在排序数组中出现的次数</h3><p><strong>题目：</strong>统计一个数字在排序数组中出现的次数。<br><strong>解题思路：</strong>用二分法找到 k ，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(data)<span class="number">-1</span></span><br><span class="line">        left = self.getLeft(data, k, start, end)</span><br><span class="line">        right = self.getRight(data, k, start, end)</span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeft</span><span class="params">(self, data, k, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> data[mid] &lt; k:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRight</span><span class="params">(self, data, k, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> data[mid] &gt; k:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> end</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题：二叉树的深度"><a href="#面试题：二叉树的深度" class="headerlink" title="面试题：二叉树的深度"></a>面试题：二叉树的深度</h3><p><strong>题目：</strong>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br><strong>解题思路：</strong>用递归，当前节点的深度 =  max( 左子树深度, 右子树深度 ) + 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if pRoot == None: return 0</span><br><span class="line">        depth_left = self.TreeDepth(pRoot.left)</span><br><span class="line">        depth_right = self.TreeDepth(pRoot.right)</span><br><span class="line">        if depth_left &gt; depth_right:</span><br><span class="line">            return depth_left + 1</span><br><span class="line">        else:</span><br><span class="line">            return depth_right + 1</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题：平衡二叉树"><a href="#面试题：平衡二叉树" class="headerlink" title="面试题：平衡二叉树"></a>面试题：平衡二叉树</h3><p><strong>题目：</strong>输入一棵二叉树，判断该二叉树是否是平衡二叉树。<br><strong>解题思路：</strong><br>用flag标记，计算左右子树深度，不平衡flag置为False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.flag = <span class="literal">True</span> </span><br><span class="line">        self.helper(pRoot)</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot <span class="keyword">or</span> self.flag == <span class="literal">False</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(pRoot.left)</span><br><span class="line">        right = self.helper(pRoot.right)</span><br><span class="line">        <span class="keyword">if</span> abs(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">            self.flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span> <span class="keyword">if</span> left &gt; right <span class="keyword">else</span> right + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="面试题：数组中只出现一次的数字"><a href="#面试题：数组中只出现一次的数字" class="headerlink" title="面试题：数组中只出现一次的数字"></a>面试题：数组中只出现一次的数字</h3><p><strong>题目：</strong>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br><strong>解法1：hashmap 计数</strong><br>时间复杂度$O(n)$，空间复杂度$O(n)$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 返回[a,b] 其中ab是出现一次的两个数字</span><br><span class="line">    def FindNumsAppearOnce(self, array):</span><br><span class="line">        # write code here</span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        for n in array:</span><br><span class="line">            count[n] = count.get(n,0) + 1</span><br><span class="line">        res = []</span><br><span class="line">        for n in count:</span><br><span class="line">            if len(res) &lt; 2 and count[n] == 1:</span><br><span class="line">                res.append(n)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：位运算</strong><br>先看如何在一个数组中找到一个只出现一次的数字，任何一个数字异或它自己都等于0，也就是说，如果从头到尾依次异或数组中的每一个数字，最终的结果刚好就是那个只出现一次的数字。</p>
<p>数组有两个数字出现一次，如果将原始数组分成两个子数组，每个子数组包含一个只出现一次的数字，而其他数字都成对出现，这样，我们就可以用上述方法找到每个数字。方法还是从头到尾异或数组中的每一个数字，最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。<strong>由于两个数字肯定不一样，那么异或的结果肯定不为0</strong>，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到<strong>第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组</strong>，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。</p>
<p>时间复杂度$O(n)$，空间复杂度$O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        eorAll = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> array:</span><br><span class="line">            eorAll ^= n</span><br><span class="line">        margin = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> eorAll &amp; margin == <span class="number">0</span>:</span><br><span class="line">            margin = margin &lt;&lt; <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        part1, part2 = [], []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> n &amp; margin == <span class="number">0</span>: part1.append(n)</span><br><span class="line">            <span class="keyword">else</span>: part2.append(n)</span><br><span class="line">        res = [<span class="number">0</span>, <span class="number">0</span>]        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> part1: res[<span class="number">0</span>] ^= n</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> part2: res[<span class="number">1</span>] ^= n</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="面试题：和为S的连续正数序列"><a href="#面试题：和为S的连续正数序列" class="headerlink" title="面试题：和为S的连续正数序列"></a>面试题：和为S的连续正数序列</h3><p><strong>题目：</strong>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def FindContinuousSequence(self, tsum):</span><br><span class="line">        small, big = 1, 2</span><br><span class="line">        small_max = (tsum + 1) / 2 </span><br><span class="line">        cur_sum = small + big</span><br><span class="line">        res = []</span><br><span class="line">        while small &lt; small_max:</span><br><span class="line">            if cur_sum == tsum:</span><br><span class="line">                res.append(range(small, big + 1))</span><br><span class="line">            if cur_sum &lt; tsum:</span><br><span class="line">                big += 1</span><br><span class="line">                cur_sum += big</span><br><span class="line">            else:</span><br><span class="line">                cur_sum -= small</span><br><span class="line">                small += 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h3 id="面试题：和为S的两个数字"><a href="#面试题：和为S的两个数字" class="headerlink" title="面试题：和为S的两个数字"></a>面试题：和为S的两个数字</h3><p><strong>题目：</strong>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br><strong>解题思路：</strong>定义<strong>两个指针，第一个指针指向数组的第一个最小的数字，第二个指针指向数组的最后一个最大的数字</strong>，如果两个数字的和大于S，则把第二个指针往前移一位；如果两个数字之和小于S，则把第一个指针往后移一位，直到两个数字之和等于S或两个指针相遇，输出结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>: <span class="keyword">return</span> []</span><br><span class="line">        idx1, idx2 = <span class="number">0</span>, len(array) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> idx1 &lt; idx2:</span><br><span class="line">            <span class="keyword">if</span> array[idx1] + array[idx2] == tsum:</span><br><span class="line">                <span class="keyword">return</span> [array[idx1], array[idx2]]</span><br><span class="line">            <span class="keyword">elif</span> array[idx1] + array[idx2] &gt; tsum:</span><br><span class="line">                idx2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题58-2：左旋转字符串"><a href="#面试题58-2：左旋转字符串" class="headerlink" title="面试题58-2：左旋转字符串"></a>面试题58-2：左旋转字符串</h3><p><strong>题目：</strong>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。<br><strong>解法一：字符子串换位</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def LeftRotateString(self, s, n):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt;= 0: return s</span><br><span class="line">        if s == None or len(s) == 0: return s</span><br><span class="line">        n = n % len(s)</span><br><span class="line">        s1 = s[:n]</span><br><span class="line">        s2 = s[n:]</span><br><span class="line">        return s2 + s1</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：三次reverse</strong><br>要把前n个字符移到后面，把字符串分成两部分，前n个字符串作为第一部分，后面的作为第二部分，先分别反转这两部分，再翻转整个字符串，就可以得到左位移后的字符串。</p>
<h3 id="面试题58-1：翻转单词顺序列"><a href="#面试题58-1：翻转单词顺序列" class="headerlink" title="面试题58-1：翻转单词顺序列"></a>面试题58-1：翻转单词顺序列</h3><p><strong>题目：</strong>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变，标点符号和其前面的普通字母一样处理。例如输入字符串“I am a student.”，输出 “student. a am I”。</p>
<p><strong>解法一：分割拼接法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def ReverseSentence(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        s_seq = s.split(&quot; &quot;)</span><br><span class="line">        return &apos; &apos;.join(s_seq[::-1])</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：两次翻转法</strong><br>第一步翻转句子中所有字符，此时不但反转了句子中的单词顺序，还翻转了单词内的字符顺序。第二步再翻转每个单词中字符的顺序。</p>
<h3 id="面试题61：扑克牌中的顺子"><a href="#面试题61：扑克牌中的顺子" class="headerlink" title="面试题61：扑克牌中的顺子"></a>面试题61：扑克牌中的顺子</h3><p><strong>题目：</strong>从扑克牌中随机抽 5 张牌，判断是不是一个顺子，2～10为数字本身，A为1，J为11，Q为12，K为13，大小王可以看作任意数字，为方便起见大小王输入记为0。<br><strong>解法一：排序计数</strong><br>首先把数组排序，统计数组中大小王的个数，统计排序后数组中相邻数字之间的空缺总数，如果空缺总数小于或等于大小王的个数，这个数组就是连续的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def IsContinuous(self, numbers):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(numbers) &lt;= 1: return False</span><br><span class="line">        numbers.sort()</span><br><span class="line">        </span><br><span class="line">        num_zero = numbers.count(0)</span><br><span class="line">        start = num_zero</span><br><span class="line">        end = start + 1</span><br><span class="line">        while end &lt; len(numbers):</span><br><span class="line">            num_gap = numbers[end] - numbers[start] - 1</span><br><span class="line">            if num_gap &lt; 0: return False</span><br><span class="line">            if num_gap &lt;= num_zero: </span><br><span class="line">                num_zero -= num_gap</span><br><span class="line">                start += 1</span><br><span class="line">                end += 1</span><br><span class="line">            else:</span><br><span class="line">                return False</span><br><span class="line">            </span><br><span class="line">        return True</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：哈希map</strong><br>用hash表对每个数字计数，如果除0外，每个数字只出现了一次，且最大键值和最小键值的差小于4，就可以组成顺子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def IsContinuous(self, numbers):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(numbers) &lt;= 1: return False</span><br><span class="line">        dict_count = &#123;&#125;</span><br><span class="line">        for num in numbers:</span><br><span class="line">            if num != 0:</span><br><span class="line">                dict_count[num] = dict_count.get(num, 0) + 1</span><br><span class="line">                if dict_count[num] &gt; 1: return False</span><br><span class="line">        return max(dict_count.keys()) - min(dict_count.keys()) &lt;= 4</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题62：圆圈中最后剩下的数字"><a href="#面试题62：圆圈中最后剩下的数字" class="headerlink" title="面试题62：圆圈中最后剩下的数字"></a>面试题62：圆圈中最后剩下的数字</h3><p><strong>题目：</strong>0,1,…,n-1这n个数字排成了一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字，求出这个圆圈里剩下的最后一个数字。</p>
<p><strong>解法一：用环形链表模拟圆圈</strong><br>创建一个共有n个节点的环形链表，每次在这个链表中删除第m个节点，空间复杂度$O(n)$，时间复杂度 $O(nm)$</p>
<p><strong>解法二：</strong>用递推公式：</p>
<pre><code>$$res[1, m] = 0 $$
$$res[n, m] = (res[n - 1][m] + m) \% n$$
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def LastRemaining_Solution(self, n, m):</span><br><span class="line">        # write code here</span><br><span class="line">        if n &lt; 1 or m &lt; 1: return -1</span><br><span class="line">        if n == 1: return 0</span><br><span class="line">        last = 0</span><br><span class="line">        for i in range(2, n+1):</span><br><span class="line">            last = (last + m) % i</span><br><span class="line">        return last</span><br></pre></td></tr></table></figure>
<h3 id="面试题64：求1-2-3-…-n"><a href="#面试题64：求1-2-3-…-n" class="headerlink" title="面试题64：求1+2+3+…+n"></a>面试题64：求1+2+3+…+n</h3><p><strong>题目：</strong>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><strong>解题思路：</strong>四则运算被限制使用的时候，尝试用二进制和位运算的方向寻找突破口。通常求1+2+3+…+n，无外乎循环和递归两种思路，循环不能用，递归需要用if语句或条件判断语句来判断是否终止递归</p>
<p><strong>解法一：python 内置函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        return sum(range(1, n+1))</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：用逻辑与的短路特性实现递归终止</strong><br>“or”运算符表示“或”，有一个为真则全部为真；前半部分判断出来是真的，后半部分就不再进行运算了；“and”运算符表示“与”，前一项为假则整个表达式为假，因此可以利用这个性质进行递归运算或者达到整洁代码的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Sum_Solution(self, n):</span><br><span class="line">        # write code here</span><br><span class="line">        res = n</span><br><span class="line">        sub = n &gt; 1 and self.Sum_Solution(n - 1)  </span><br><span class="line">        return res + sub</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题65：不用加减乘除做加法"><a href="#面试题65：不用加减乘除做加法" class="headerlink" title="面试题65：不用加减乘除做加法"></a>面试题65：不用加减乘除做加法</h3><p><strong>题目：</strong>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、<em>、/四则运算符号。<br><em>*解题思路：</em></em>把二进制的加法用位运算代替。第一步求异或，不考虑进位对每一位相加；第二步考虑进位，先做位与运算，再向左移动一位；第三步把前两步的结果以同样的方法相加，知道不产生进位为止。</p>
<p><strong>注意：在Python中，对于超出32位的大整数，会自动进行大整数的转变，这就导致了在右移位过程中出现死循环。需要在移动的过程中把carry的值和0xFFFFFFFF做比较判断一下</strong></p>
<p>？？？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Add(self, num1, num2):</span><br><span class="line">        # write code here</span><br><span class="line">        sum_eor = num1</span><br><span class="line">        while num2 != 0:</span><br><span class="line">            sum_eor = num1 ^ num2</span><br><span class="line">            carry = 0xFFFFFFFF &amp; ((num1 &amp; num2) &lt;&lt; 1)</span><br><span class="line">            carry = -(~(carry - 1) &amp; 0xFFFFFFFF) if carry &gt; 0x7FFFFFFF else carry</span><br><span class="line">            num1 = sum_eor</span><br><span class="line">            num2 = carry</span><br><span class="line">        return sum_eor</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题67：把字符串转换成整数"><a href="#面试题67：把字符串转换成整数" class="headerlink" title="面试题67：把字符串转换成整数"></a>面试题67：把字符串转换成整数</h3><p><strong>题目：</strong>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br><strong>解题思路：</strong>注意字符串正负号，空字符串，除数字外的非法字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def StrToInt(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        if len(s) == 0: return 0</span><br><span class="line">        </span><br><span class="line">        res = 0</span><br><span class="line">        flag = 1</span><br><span class="line">        char_idx = 0</span><br><span class="line">        if s[0] in &quot;+-&quot;:</span><br><span class="line">            flag = flag if s[0] == &apos;+&apos; else -1 * flag</span><br><span class="line">            s = s[1:]</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i] in &apos;0123456789&apos;:</span><br><span class="line">                res = res * 10 + ord(s[i]) - 48</span><br><span class="line">                </span><br><span class="line">            else:</span><br><span class="line">                return 0</span><br><span class="line">        return res * flag</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题：数组中重复的数字"><a href="#面试题：数组中重复的数字" class="headerlink" title="面试题：数组中重复的数字"></a>面试题：数组中重复的数字</h3><p><strong>题目：</strong>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def duplicate(self, numbers, duplication):</span><br><span class="line">        # write code here</span><br><span class="line">        flag = True</span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        for num in numbers:</span><br><span class="line">            count[num] = count.get(num, 0) + 1</span><br><span class="line">            if count[num] &gt; 1:</span><br><span class="line">                duplication[0] = num</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h3 id="面试题：构建乘积数组"><a href="#面试题：构建乘积数组" class="headerlink" title="面试题：构建乘积数组"></a>面试题：构建乘积数组</h3><p><strong>题目：</strong>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        B_front = [i <span class="keyword">for</span> i <span class="keyword">in</span> A]</span><br><span class="line">        B_back = [i <span class="keyword">for</span> i <span class="keyword">in</span> A]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            B_front[i] = B_front[i<span class="number">-1</span>] * A[i]</span><br><span class="line">            B_back[len(B_back)<span class="number">-1</span>-i] = B_back[len(B_back)-i] * A[len(B_back)<span class="number">-1</span>-i]</span><br><span class="line">        B = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(A))]</span><br><span class="line">        B[<span class="number">0</span>] = B_back[<span class="number">1</span>]</span><br><span class="line">        B[len(A)<span class="number">-1</span>] = B_front[len(A)<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)<span class="number">-1</span>):</span><br><span class="line">            B[i] = B_front[i<span class="number">-1</span>] * B_back[i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>
<h3 id="面试题：正则表达式匹配"><a href="#面试题：正则表达式匹配" class="headerlink" title="面试题：正则表达式匹配"></a>面试题：正则表达式匹配</h3><p><strong>题目：</strong>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’<em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab</em>ac<em>a”匹配，但是与”aa.a”和”ab</em>a”均不匹配<br><strong>解题思路：</strong>用递归，每次只匹配 s 中的一个字符：</p>
<ul>
<li>如果s和patten都为空，匹配成功；</li>
<li>如果patten是空串，而s不是，匹配失败；</li>
<li><p>如果s,patten均不是空串，分两种情况考虑：</p>
<ul>
<li><p>如果patten的第二个字符是“*”：<br>(1) 当s和patten的第一个字符匹配，剩余部分有两种匹配方式，第一种是s后移一位，相当于“*”前的字符在s中出现不止一次，第二种是patten后移两位，相当于“*”前的字符在s中出现了0次；<br>(2) 如果s和patten不匹配，则patten后移两位，表示“*”前的字符在s中出现了0次。</p>
</li>
<li><p>如果patten的第二个字符不是“*”，则当s和patten第一个字符匹配时，s和patten同时后移一位，继续匹配，否则匹配失败。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, pattern)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span> <span class="keyword">and</span> len(pattern) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> len(pattern) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(pattern) &gt; <span class="number">1</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span>):</span><br><span class="line">                <span class="keyword">return</span> self.match(s, pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:], pattern)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.match(s, pattern[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span>):</span><br><span class="line">            <span class="keyword">return</span> self.match(s[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="面试题：表示数值的字符串"><a href="#面试题：表示数值的字符串" class="headerlink" title="面试题：表示数值的字符串"></a>面试题：表示数值的字符串</h3><p><strong>题目：</strong>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br><strong>解题思路：</strong> 用re判断：</p>
<ul>
<li><code>^[\+\-]?[0-9]*</code> 字符串头部是否存在正负号</li>
<li><code>(\.[0-9]*)?</code> 判断是否存在小数点</li>
<li><code>([eE][\+\-]?[0-9]+)?</code> 出现e/E后面必须有数字</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> re.match(<span class="string">r"^[\+\-]?[0-9]*(\.[0-9]*)?([eE][\+\-]?[0-9]+)?$"</span>, s)</span><br></pre></td></tr></table></figure>
<h3 id="面试题：字符流中第一个不重复的字符"><a href="#面试题：字符流中第一个不重复的字符" class="headerlink" title="面试题：字符流中第一个不重复的字符"></a>面试题：字符流中第一个不重复的字符</h3><p><strong>题目：</strong>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p><strong>解题思路：</strong>设置全局变量，用字典计数，插入时更新全局变量！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应char</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = &#123;&#125;</span><br><span class="line">        self.str = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.count <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> self.str:</span><br><span class="line">            <span class="keyword">if</span> self.count[char] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> char</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.str.append(char)</span><br><span class="line">        self.count[char] = self.count.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="面试题：链表中环的入口结点"><a href="#面试题：链表中环的入口结点" class="headerlink" title="面试题：链表中环的入口结点"></a>面试题：链表中环的入口结点</h3><p><strong>题目：</strong>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<br><strong>解题思路：</strong>快慢指针的经典问题，</p>
<h3 id="面试题：删除链表中重复的结点"><a href="#面试题：删除链表中重复的结点" class="headerlink" title="面试题：删除链表中重复的结点"></a>面试题：删除链表中重复的结点</h3><p><strong>题目：</strong>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        first = ListNode(<span class="number">-1</span>)</span><br><span class="line">        first.next = pHead</span><br><span class="line">        last = first</span><br><span class="line">        <span class="keyword">while</span> pHead <span class="keyword">and</span> pHead.next:</span><br><span class="line">            <span class="keyword">if</span> pHead.val == pHead.next.val:</span><br><span class="line">                val = pHead.val</span><br><span class="line">                <span class="keyword">while</span> pHead <span class="keyword">and</span> val == pHead.val:</span><br><span class="line">                    pHead = pHead.next</span><br><span class="line">                last.next = pHead</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last = pHead</span><br><span class="line">                pHead = pHead.next</span><br><span class="line">        <span class="keyword">return</span> first.next</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题：二叉树的下一个节点"><a href="#面试题：二叉树的下一个节点" class="headerlink" title="面试题：二叉树的下一个节点"></a>面试题：二叉树的下一个节点</h3><p><strong>题目：</strong>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><strong>解题思路：</strong>给定一个节点：</p>
<ul>
<li>如果有右子树，那么下一个节点是右子树的最左节点；</li>
<li>如果没有右子树，则向上找其父节点，使得给定的节点在该父节点的左子树中；</li>
<li>右子树和父节点都没有，则返回None；</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pNode <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pNode.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> pNode.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> pNode.next <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            res = pNode.right</span><br><span class="line">            <span class="keyword">while</span> res.left:</span><br><span class="line">                res = res.left</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">while</span> pNode.next:</span><br><span class="line">            <span class="keyword">if</span> pNode.next.left == pNode:</span><br><span class="line">                <span class="keyword">return</span> pNode.next</span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="面试题：对称的二叉树"><a href="#面试题：对称的二叉树" class="headerlink" title="面试题：对称的二叉树"></a>面试题：对称的二叉树</h3><p><strong>题目：</strong>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br><strong>解题思路：</strong>对称树满足：</p>
<ul>
<li>根节点相同；</li>
<li>根节点左右子树相同；</li>
<li>左子树的左子树和右子树的右子树相同，左子树的右子树和右子树的左子树相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(pRoot.left, pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, pLeft, pRight)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pLeft == <span class="literal">None</span> <span class="keyword">and</span> pRight == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> pLeft == <span class="literal">None</span> <span class="keyword">or</span> pRight == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> pLeft.val != pRight.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(pLeft.right, pRight.left) <span class="keyword">and</span> self.helper(pLeft.left, pRight.right)</span><br></pre></td></tr></table></figure>
<h3 id="面试题：按之字形顺序打印二叉树"><a href="#面试题：按之字形顺序打印二叉树" class="headerlink" title="面试题：按之字形顺序打印二叉树"></a>面试题：按之字形顺序打印二叉树</h3><p><strong>题目：</strong>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><strong>解题思路：</strong>用两个栈来实现，利用栈先进后出的特点，分别存储奇数层和偶数层的节点，比如第一层进入stack1，stack1 中依次出栈，并将其左子节点、右子节点先后加入stack2。stack2 出栈的时候，其子节点加入stack1的顺序是<strong>先右后左</strong>，…</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> []</span><br><span class="line">        stack1 = [pRoot]</span><br><span class="line">        stack2 = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2:</span><br><span class="line">            res1 = []</span><br><span class="line">            res2 = []</span><br><span class="line">            <span class="keyword">while</span> stack1:</span><br><span class="line">                node = stack1.pop()</span><br><span class="line">                <span class="keyword">if</span> node.left: stack2.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: stack2.append(node.right)</span><br><span class="line">                res1.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> len(res1) != <span class="number">0</span>: res.append(res1)</span><br><span class="line">            <span class="keyword">while</span> stack2:</span><br><span class="line">                node = stack2.pop()</span><br><span class="line">                <span class="keyword">if</span> node.right: stack1.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: stack1.append(node.left)</span><br><span class="line">                res2.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> len(res2) != <span class="number">0</span>: res.append(res2)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="面试题：把二叉树打印成多行"><a href="#面试题：把二叉树打印成多行" class="headerlink" title="面试题：把二叉树打印成多行"></a>面试题：把二叉树打印成多行</h3><p><strong>题目：</strong>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br><strong>解题思路：</strong>用列表存储二叉树每一层节点，每读取一层，按从左到右的顺序存储下一层节点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        cur_list = [pRoot]</span><br><span class="line">        next_list = []</span><br><span class="line">        <span class="keyword">while</span> len(cur_list) &gt; <span class="number">0</span>:</span><br><span class="line">            cur_res = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> cur_list:</span><br><span class="line">                <span class="keyword">if</span> node.left: next_list.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: next_list.append(node.right)</span><br><span class="line">                cur_res.append(node.val)</span><br><span class="line">            res.append(cur_res)</span><br><span class="line">            cur_list = next_list</span><br><span class="line">            next_list = []</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h3 id="面试题：序列化二叉树"><a href="#面试题：序列化二叉树" class="headerlink" title="面试题：序列化二叉树"></a>面试题：序列化二叉树</h3><p><strong>题目：</strong>实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Serialize(self, root):</span><br><span class="line">        # write code here</span><br><span class="line">        if root == None:</span><br><span class="line">            return &apos;#&apos;</span><br><span class="line">        return str(root.val) + &apos;,&apos; + self.Serialize(root.left) + &apos;,&apos; + self.Serialize(root.right)</span><br><span class="line">    </span><br><span class="line">    def Deserialize(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        def deserialize_helper(serialize_list):</span><br><span class="line">            if len(serialize_list) == 0: return None</span><br><span class="line">            val = serialize_list.pop(0)</span><br><span class="line">            root = None</span><br><span class="line">            if val != &apos;#&apos;:</span><br><span class="line">                root = TreeNode(int(val))</span><br><span class="line">                root.left = deserialize_helper(serialize_list)</span><br><span class="line">                root.right = deserialize_helper(serialize_list)</span><br><span class="line">            return root</span><br><span class="line">        </span><br><span class="line">        serialize_list = s.split(&apos;,&apos;)</span><br><span class="line">        return deserialize_helper(serialize_list)</span><br></pre></td></tr></table></figure>
<h3 id="面试题：二叉搜索树的第k个结点"><a href="#面试题：二叉搜索树的第k个结点" class="headerlink" title="面试题：二叉搜索树的第k个结点"></a>面试题：二叉搜索树的第k个结点</h3><p><strong>题目：</strong>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。<br><strong>解题思路：</strong>二叉搜索树的中序遍历正好是一个递增的序列, 因此中序遍历的第K个结点就是二叉搜索树的第K个节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">global</span> inorder_res</span><br><span class="line">        inorder_res = []</span><br><span class="line">        self.inorder(pRoot)</span><br><span class="line">        <span class="keyword">if</span> len(inorder_res) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> inorder_res[k - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.inorder(root.left)</span><br><span class="line">        inorder_res.append(root)</span><br><span class="line">        self.inorder(root.right)</span><br></pre></td></tr></table></figure>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });

</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->

</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/junlian.github.io/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/junlian.github.io/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
