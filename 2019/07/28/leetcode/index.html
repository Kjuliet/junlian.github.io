<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Juliet&#39;s blog">
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/junlian.github.io/img/favicon.ico">

    <title>
        
        leetcode - 学 | 慢慢来
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/junlian.github.io/css/aircloud.css">
    <link rel="stylesheet" href="/junlian.github.io/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所谓诚其意者，毋自欺也，如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也。 ——摘《大学》 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/junlian.github.io/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>慎思之，笃行之</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/junlian.github.io/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/junlian.github.io/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/junlian.github.io/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/junlian.github.io/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0001-两数之和"><span class="toc-text">0001.两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0004-寻找两个有序数组的中位数"><span class="toc-text">0004. 寻找两个有序数组的中位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0006-Z-字形变换"><span class="toc-text">0006. Z 字形变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0008-字符串转换整数-atoi"><span class="toc-text">0008. 字符串转换整数 (atoi)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#97-交错字符串"><span class="toc-text">97. 交错字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-实现-strStr"><span class="toc-text">28. 实现 strStr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-串联所有单词的子串"><span class="toc-text">30. 串联所有单词的子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0015-三数之和"><span class="toc-text">0015. 三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0016-最接近的三数之和"><span class="toc-text">0016. 最接近的三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0018-四数之和"><span class="toc-text">0018. 四数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0017-电话号码的字母组合"><span class="toc-text">0017. 电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0026-删除排序数组中的重复项"><span class="toc-text">0026. 删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0027-移除元素"><span class="toc-text">0027. 移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0033-搜索旋转排序数组"><span class="toc-text">0033. 搜索旋转排序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0034-在排序数组中查找元素的第一个和最后一个位置"><span class="toc-text">0034. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0035-搜索插入位置"><span class="toc-text">0035. 搜索插入位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0036-有效的数独"><span class="toc-text">0036. 有效的数独</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0041-缺失的第一个正数"><span class="toc-text">0041. 缺失的第一个正数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0002-两数相加"><span class="toc-text">0002. 两数相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0019-删除链表的倒数第N个节点"><span class="toc-text">0019. 删除链表的倒数第N个节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0021-合并两个有序链表"><span class="toc-text">0021. 合并两个有序链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0023-合并K个排序链表"><span class="toc-text">0023. 合并K个排序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0024-两两交换链表中的节点"><span class="toc-text">0024. 两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0025-K-个一组翻转链表"><span class="toc-text">0025. K 个一组翻转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0003-无重复字符的最长子串"><span class="toc-text">0003. 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0005-最长回文子串"><span class="toc-text">0005. 最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#115-不同的子序列"><span class="toc-text">115. 不同的子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#727-最小窗口子序列"><span class="toc-text">727. 最小窗口子序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算操作"><span class="toc-text">位运算操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-编程"><span class="toc-text">python 编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#斐波那契数列"><span class="toc-text">斐波那契数列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#矩阵连乘："><span class="toc-text">矩阵连乘：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#95-不同的二叉搜索树-II"><span class="toc-text">95. 不同的二叉搜索树 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-验证二叉搜索树"><span class="toc-text">98. 验证二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#99-恢复二叉搜索树"><span class="toc-text">99. 恢复二叉搜索树</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 所谓诚其意者，毋自欺也，如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也。 ——摘《大学》 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        leetcode
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-07-28 02:33:30</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h3 id="0001-两数之和"><a href="#0001-两数之和" class="headerlink" title="0001.两数之和"></a>0001.两数之和</h3><p><strong>题目：</strong>给定一个整数数组 nums 和一个目标值 target，要在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。每种输入只会对应一个答案。但是不能重复利用这个数组中同样的元素。</p>
<p><strong>解法一：</strong>因为要输出元素的下标，所以将原来的拷贝一份，然后排序，在排序后的数组中，用两个指针，一个指向头，一个指向尾，两个指针向中间移动并检查两个指针指向的数的和是否为target，找到这两个数后再将它们在原数组中的位置找出来即可。</p>
<p>Leetcode 上会超时：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        numtosort = nums[:];  <span class="comment"># 深拷贝</span></span><br><span class="line">        numtosort.sort()</span><br><span class="line">        i, j = <span class="number">0</span>, len(numtosort) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j):</span><br><span class="line">            <span class="keyword">if</span> numtosort[i] + numtosort[j] == target:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                    <span class="keyword">if</span> nums[k] == numtosort[i] :</span><br><span class="line">                        res.append(i)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> nums[k] == numtosort[j]:</span><br><span class="line">                        res.append(j)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> numtosort[i] + numtosort[j] &lt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：</strong>用字典存储<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums) &lt; <span class="number">2</span>: <span class="keyword">return</span> []</span><br><span class="line">        helper_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - n <span class="keyword">not</span> <span class="keyword">in</span> helper_dict:</span><br><span class="line">                helper_dict[n] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [helper_dict[target-n], i]</span><br></pre></td></tr></table></figure></p>
<h3 id="0004-寻找两个有序数组的中位数"><a href="#0004-寻找两个有序数组的中位数" class="headerlink" title="0004. 寻找两个有序数组的中位数"></a>0004. 寻找两个有序数组的中位数</h3><p><strong>题目：</strong> 求两个已排好序的数列的中位数<br><strong>解题思路：</strong>递归。如何找到<strong>两个数列的第k小的数</strong>，用一个例子来说明，A=[1, 3, 5, 7], B = [2, 4, 6, 8, 9, 10]，如果要求第 7 个小的数，A 数列的元素个数为4，B数列的元素个数为 6 ，K / 2 = 7 / 2 = 3，A 中的第3个数是 5 ，B 中的第 3 个数是 6，A[2] &lt; B[2]，则A[0], A[1], A[2] 中必然不可能有第 7 个小的数，因为 A[2] &lt; B[2], 所以比 A[2] 小的数最多可能有A[0], A[1], B[0], B[1] 这 4 个数，也就是说A[2] 最多可能是第 5 大的数。我们要找的是getKth(A, B, 7)，经过第一次比较后就变成了getKth(A’, B, 4)，A’ = [7], B 不变，求这两个数列的第 4 个小的数，A[0], A[1], A[2]中没有解，直接删掉就可以了。这个过程用递归实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        len1, len2 = len(nums1), len(nums2)</span><br><span class="line">        <span class="keyword">if</span>(len1 + len2) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.getKth(nums1, nums2, (len1+len2)//<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.getKth(nums1, nums2, (len1+len2)//<span class="number">2</span>) + self.getKth(nums1, nums2, (len1+len2)//<span class="number">2</span>+<span class="number">1</span>)) * <span class="number">0.5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKth</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">        len1, len2 = len(nums1), len(nums2)</span><br><span class="line">        <span class="keyword">if</span> len1 &gt; len2: <span class="keyword">return</span> self.getKth(nums2, nums1, k) <span class="comment"># 总是短的在前</span></span><br><span class="line">        <span class="keyword">if</span> len1 == <span class="number">0</span>: <span class="keyword">return</span> nums2[k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>: <span class="keyword">return</span> min(nums1[<span class="number">0</span>], nums2[<span class="number">0</span>])</span><br><span class="line">        pa = min(k // <span class="number">2</span>, len1)       <span class="comment"># 每次排除min(k//2, len1)个数</span></span><br><span class="line">        pb = k - pa</span><br><span class="line">        <span class="keyword">if</span> nums1[pa - <span class="number">1</span>] &lt;= nums2[pb - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.getKth(nums1[pa:], nums2, pb)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.getKth(nums1, nums2[pb:], pa)</span><br></pre></td></tr></table></figure>
<h3 id="0006-Z-字形变换"><a href="#0006-Z-字形变换" class="headerlink" title="0006. Z 字形变换"></a>0006. Z 字形变换</h3><p><strong>题目：</strong>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br><img src="./Screen Shot 2019-08-24 at 12.52.45 AM.png" alt="Alt text"></p>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。<br>实现这个将字符串进行指定行数变换的函数。</p>
<p><strong>解法一：</strong>一行加满加下一行，对于有重复模式出现的形状，找其中差的规律：interval = 2 <em> numRows - 2; step = interval - 2 </em> row，step 在 (0, interval)之间。对每一行里的每一列，先判断该列是否是mid 列，如果是按step加，如果不是，按interval加。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">if</span> numRows &gt; length <span class="keyword">or</span> numRows &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        res = []</span><br><span class="line">        interval = <span class="number">2</span> * numRows - <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</span><br><span class="line">            step = interval - <span class="number">2</span> * i</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &lt; length:</span><br><span class="line">                res.append(s[j])         <span class="comment"># 每一行先加 i </span></span><br><span class="line">                <span class="keyword">if</span> step &gt; <span class="number">0</span> <span class="keyword">and</span> step &lt; interval <span class="keyword">and</span> j + step &lt; length:  <span class="comment"># 当interval中间有元素时</span></span><br><span class="line">                    res.append(s[j+step])</span><br><span class="line">                j += interval</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：</strong>一次生成所有的行，按字符串的顺序从前到后加到各自行中，加到第一行时，step 为1，加到最后一行时，step 为 -1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>: <span class="keyword">return</span> s</span><br><span class="line">        zigzag = [<span class="string">''</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numRows)] <span class="comment"># 一项对应一行</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">0</span>:</span><br><span class="line">                step = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row == numRows - <span class="number">1</span>:</span><br><span class="line">                step = <span class="number">-1</span></span><br><span class="line">            zigzag[row] += c</span><br><span class="line">            row += step</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(zigzag)</span><br></pre></td></tr></table></figure></p>
<h3 id="0008-字符串转换整数-atoi"><a href="#0008-字符串转换整数-atoi" class="headerlink" title="0008. 字符串转换整数 (atoi)"></a>0008. 字符串转换整数 (atoi)</h3><p><strong>题目：</strong>将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：假设环境只能存储 32 位大小的有符号整数，所以数值范围为 $[−2^{31},  2^{31} − 1]$。如果数值超过这个范围，请返回  $INT_MAX (2^{31} − 1) $或 $INT_MIN (−2^{31}) $。</p>
<p><strong>解法一：</strong>按照上面的点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        str = str.strip()  <span class="comment"># strip()移除字符串头尾指定的字符，默认为空格</span></span><br><span class="line">        <span class="keyword">if</span> len(str) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        number, flag = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">            str = str[<span class="number">1</span>:]</span><br><span class="line">            flag = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> str[<span class="number">0</span>] == <span class="string">'+'</span>: str = str[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str:</span><br><span class="line">            <span class="keyword">if</span> c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>:</span><br><span class="line">                number = <span class="number">10</span> * number + ord(c) - ord(<span class="string">'0'</span>)  <span class="comment"># ord(c)返回字符c的ASCII数字</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        number = flag * number</span><br><span class="line">        number = number <span class="keyword">if</span> number &lt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span> <span class="keyword">else</span> <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br><span class="line">        number = number <span class="keyword">if</span> number &gt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">else</span> <span class="number">-2</span>**<span class="number">31</span></span><br><span class="line">        <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：用正则表达式简化过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, str: str) -&gt; int:</span><br><span class="line">        if not str: return 0</span><br><span class="line">        str = str.strip()  # strip()移除字符串头尾指定的字符，默认为空格</span><br><span class="line">        try:</span><br><span class="line">            res = re.search(&apos;(^[\+\-]?\d+)&apos;, str).group()</span><br><span class="line">            res = int(res)</span><br><span class="line">            res = res if res &lt;= 2**31-1 else 2**31-1</span><br><span class="line">            res = res if res &gt;= -2**31 else -2**31</span><br><span class="line">        except:</span><br><span class="line">            res = 0</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></p>
<p>正则表达式 re</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = <span class="string">'123abc456'</span></span><br><span class="line"><span class="keyword">print</span> (re.search(<span class="string">'([0-9]*)([a-z]*)([0-9]*)'</span>, a).group(<span class="number">0</span>)) <span class="comment"># 123abc456</span></span><br><span class="line"><span class="keyword">print</span> (re.search(<span class="string">'([0-9]*)([a-z]*)([0-9]*)'</span>, a).group(<span class="number">1</span>)) <span class="comment"># 123</span></span><br><span class="line"><span class="keyword">print</span> (re.search(<span class="string">'([0-9]*)([a-z]*)([0-9]*)'</span>, a).group(<span class="number">2</span>)) <span class="comment"># abc</span></span><br><span class="line"><span class="keyword">print</span> (re.search(<span class="string">'([0-9]*)([a-z]*)([0-9]*)'</span>, a).group(<span class="number">3</span>)) <span class="comment"># 456</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">group() = group(0), 返回匹配正则表达式的整体结果</span></span><br><span class="line"><span class="string">group(1)列出第一个括号匹配部分，group(1)第二个匹配部分，...，如果没有匹配成功，re.rearch() 返回 None</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a>97. 交错字符串</h4><p><strong>题目：</strong>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的，而且不改变 s1 和 s2 中各个字符原有的相对顺序。<br><strong>解题思路：</strong>动态规划。dp[i][j] 表示s1[0…i-1] 和 s2[0…j-1] 是否可以拼接为s3[0…i+j-1]。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) + len(s2) != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s2)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s1) + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] <span class="keyword">and</span> s1[i<span class="number">-1</span>] == s3[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(s2) + <span class="number">1</span>):</span><br><span class="line">            dp[j][<span class="number">0</span>] = dp[j<span class="number">-1</span>][<span class="number">0</span>] <span class="keyword">and</span> s2[j<span class="number">-1</span>] == s3[j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s2) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(s1) + <span class="number">1</span>):</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] <span class="keyword">and</span> s2[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]) <span class="keyword">or</span> (dp[i][j<span class="number">-1</span>] <span class="keyword">and</span> s1[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[len(s2)][len(s1)]</span><br></pre></td></tr></table></figure></p>
<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><p><strong>题目：</strong>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p><strong>解题思路：</strong>模式匹配问题，考虑KMP 算法，该算法对任何模式和目标序列，都可以在线性时间内完成匹配查找 $O(n+m)$ ，而不会发生退化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:  <span class="comment"># needle为空，则匹配第一位</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 生成next数组，需要O(n)的时间</span></span><br><span class="line">        <span class="comment"># i=-1意思是如果第1位不匹配，j已经在0位，没有办法后移了，只能i往后移动</span></span><br><span class="line">        k, j, m, n = <span class="number">-1</span>, <span class="number">0</span>, len(haystack), len(needle)</span><br><span class="line">        next = [<span class="number">-1</span>] * n</span><br><span class="line">        <span class="keyword">while</span> j &lt; n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">-1</span> <span class="keyword">or</span> needle[k] == needle[j]:</span><br><span class="line">                k = k + <span class="number">1</span></span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> needle[k] == needle[j]:</span><br><span class="line">                    next[j] = next[k]</span><br><span class="line">                next[j] = k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k = next[k]  <span class="comment"># 当needle[k] != needle[j] 时，k = next[k]!</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">-1</span> <span class="keyword">or</span> haystack[i] == needle[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = next[j]</span><br><span class="line">        <span class="keyword">if</span> j == len(needle):</span><br><span class="line">            <span class="keyword">return</span> i - j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a>30. 串联所有单词的子串</h3><p><strong>题目：</strong>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。<br>输入：s = “barfoothefoobarman”, words = [“foo”,”bar”]<br>输出：[0,9]<br>从索引 0 和 9 开始的子串分别是 “barfoor” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。</p>
<p><strong>解题思路：</strong>用一个字典统计words中每个单词的数量，因为每个单词的长度一样，以题中给的例子而言，可以3个字母3个字母检查，如果不在字典中，则break出循环，有一个技巧是建立一个临时字典cur，用来统计S中在words中的单词的数量，必须和L中单词的数量相等，否则break。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s: str, words: List[str])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words: <span class="keyword">return</span> []</span><br><span class="line">        wordsDic = &#123;&#125;</span><br><span class="line">        wordNum = len(words)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> words:</span><br><span class="line">            wordsDic[i] = wordsDic.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        wordLen = len(words[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) + <span class="number">1</span> - wordLen * wordNum):  <span class="comment"># 后面要留words长个字符</span></span><br><span class="line">            curr = &#123;&#125;</span><br><span class="line">            j = <span class="number">0</span>  <span class="comment"># 用j标记匹配s子串的第几个单词</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; wordNum:</span><br><span class="line">                word = s[i + j * wordLen:i + j * wordLen + wordLen]</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> wordsDic:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                curr[word] = curr.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> curr[word] &gt; wordsDic[word]: <span class="keyword">break</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == wordNum:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="0015-三数之和"><a href="#0015-三数之和" class="headerlink" title="0015. 三数之和"></a>0015. 三数之和</h3><p><strong>题目：</strong>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ，找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。<br><strong>解题思路：</strong>先将数组排序，然后按照TwoSum的思路来解，将num[i]的相反数即-num[i] 作为 target，然后从 i+1 到 len(num)-1 的数组元素中寻找两个数使它们的和为-num[i]，注意下标范围是从0到len(num) - 3，过程中需要去重。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):  <span class="comment"># 后面至少留两个数</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> nums[i] &gt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                left = i + <span class="number">1</span>; right = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    <span class="keyword">if</span> nums[left] + nums[right] == -nums[i]:</span><br><span class="line">                        res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                        left += <span class="number">1</span>; right -= <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 去重，和上一个相比，跳过重复的</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left - <span class="number">1</span>]: left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right + <span class="number">1</span>]: right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[left] + nums[right] &lt; -nums[i]:</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> nums[left] &gt; nums[left - <span class="number">1</span>]: <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> nums[right] &lt; nums[right + <span class="number">1</span>]: <span class="keyword">break</span> </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="0016-最接近的三数之和"><a href="#0016-最接近的三数之和" class="headerlink" title="0016. 最接近的三数之和"></a>0016. 最接近的三数之和</h3><p><strong>题目：</strong>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。<br><strong>解题思路：</strong>用一个变量mindiff 来监测和与target之间的距离，如果差值为0，直接返回sum值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 在新版本中，对整型数值没有限制了，标准提供了sys.maxsize 来表示一个大于任何实际工作中能够表示的最大的整型数值</span></span><br><span class="line">        middiff = sys.maxsize</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">            left = i + <span class="number">1</span>; right = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">                diff = abs(sum - target)</span><br><span class="line">                <span class="keyword">if</span> diff &lt; middiff:</span><br><span class="line">                    middiff = diff</span><br><span class="line">                    res = sum</span><br><span class="line">                <span class="keyword">if</span> sum == target: <span class="keyword">return</span> sum</span><br><span class="line">                <span class="keyword">elif</span> sum &lt; target: left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right -= <span class="number">1</span>     </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h3 id="0018-四数之和"><a href="#0018-四数之和" class="headerlink" title="0018. 四数之和"></a>0018. 四数之和</h3><p><strong>题目：</strong>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。<br><strong>解法一：</strong>同3sum，先遍历选两个数，剩下两个数用TwoSum的思路<br><strong>解法二：</strong>用哈希表空间换时间，先建立一个字典，字典的key是数组中两两元素之和，每个key对应的value是这两个元素的下标组成的元组，元组不一定是唯一的，比如对于num=[1, 2, 3, 2] 来说，dict = {3: [(0, 1), (0, 3)], 4:[(0, 2), (1, 3)], 5:[(1, 2), (2, 3)]}，这样就可以检查target - key 这个值在不在dict的key中，如果target - key 在 dict 中且下标符合要求，则找到一组解。因为需要去重，所以用set()类型的数据结构，即无序无重复元素集，最后将每个找出来的解set() 类型转换成list类型输出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        numLen = len(nums)</span><br><span class="line">        res = set()  <span class="comment"># 去重</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> numLen &lt; <span class="number">4</span>: <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()    <span class="comment"># 万年不变先排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numLen):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, numLen):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                    dict[nums[i] + nums[j]] = [(i, j)]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dict[nums[i] + nums[j]].append((i,j))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numLen<span class="number">-3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, numLen<span class="number">-2</span>):</span><br><span class="line">                T = target - nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">if</span> T <span class="keyword">in</span> dict:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> dict[T]:</span><br><span class="line">                        <span class="keyword">if</span> k[<span class="number">0</span>] &gt; j:    <span class="comment"># 要求两个数都在j之后，因为j是第二个数</span></span><br><span class="line">                            res.add((nums[i], nums[j], nums[k[<span class="number">0</span>]], nums[k[<span class="number">1</span>]])) <span class="comment"># 只能存(a, b, c, d)，存[a,b,c,d]会报hash错误</span></span><br><span class="line">        <span class="keyword">return</span> [list(i) <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure></p>
<h3 id="0017-电话号码的字母组合"><a href="#0017-电话号码的字母组合" class="headerlink" title="0017. 电话号码的字母组合"></a>0017. 电话号码的字母组合</h3><p><strong>题目：</strong>给定一个仅包含数字 2-9 的字符串，数字到字母的映射与电话按键相同。注意 1 不对应任何字母，返回所有它能表示的字母组合。<br><strong>解题思路：</strong>用递归或dfs，一次加一个数字的字母，产生的结果数乘以3，因为每个数字可以对应三种情况:</p>
<ul>
<li>先加第一个数字，letterCombBt 一次一共产生3种结果；</li>
<li>再加第二个数字，letterCombBt 一次一共产生3 x 3 = 9种结果；<br>python 是同时产生的！不是深度加入，是广度加入！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def letterCombinations(self, digits):</span><br><span class="line">        if not digits: return []</span><br><span class="line">        self.DigitDict = &#123;2:&apos;abc&apos;, 3: &apos;def&apos;, 4: &apos;ghi&apos;, 5: &apos;jkl&apos;, 6: &apos;mno&apos;, 7: &apos;pqrs&apos;, 8:&apos;tuv&apos;, 9:&apos;wxyz&apos;&#125;</span><br><span class="line">        res = [&apos;&apos;]</span><br><span class="line">        for d in digits:</span><br><span class="line">            res = self.letterCombBT(int(d), res)</span><br><span class="line">        return res</span><br><span class="line">    def letterCombBT(self, digit, oldStrList):</span><br><span class="line">        return [dstr + i for i in self.DigitDict[digit] for dstr in oldStrList]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="0026-删除排序数组中的重复项"><a href="#0026-删除排序数组中的重复项" class="headerlink" title="0026. 删除排序数组中的重复项"></a>0026. 删除排序数组中的重复项</h3><p><strong>题目：</strong>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br><strong>解题思路：</strong>遍历列表，以nums[0]为基准，下标指针 j 为 0 ，逐一与后面元素比较找出不等元素，将不等元素放到第二个元素的位置 nums[1]，此时 j + 1，再以 nums[1]为基准元素找下一个不等元素，以此类推将不等元素放到 nums 列表靠前区域，返回 j + 1 即为不重复列表长度，截取的nums列表前 j+1个元素即为不重复的列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != nums[i]:      <span class="comment"># j 代表的是基准位置，表示已经确定加入的最后一个位置</span></span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[i]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="0027-移除元素"><a href="#0027-移除元素" class="headerlink" title="0027. 移除元素"></a>0027. 移除元素</h3><p><strong>题目：</strong>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<strong>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素（看到这个提示应该想到用类似快排的方法！）</strong><br><strong>解题思路：</strong>使用头尾指针，头指针碰到要删除的元素val时，与尾指针的元素交换，将 val 都换到数组的末尾去。注意换回来的值需要重新检查合法性！如果头指针从前到后，则需要回退指针检验！</p>
<p>所以可以选择从后往前验重，可以不用再检查换回来的值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        j = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):   <span class="comment"># 从后往前，倒序</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                nums[i] = nums[j]   <span class="comment"># nums[j] 是什么无所谓了</span></span><br><span class="line">                <span class="comment"># 不用再次检查换过来的值，因为i是从后往前检查的，当后面的值为val时，j-=1了！！所以换到前面的值一定不是val！不用检查！！</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="0033-搜索旋转排序数组"><a href="#0033-搜索旋转排序数组" class="headerlink" title="0033. 搜索旋转排序数组"></a>0033. 搜索旋转排序数组</h3><p><strong>题目：</strong>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。可以假设数组中不存在重复的元素。算法时间复杂度必须是 O(log n) 级别。<br><strong>解题思路：</strong>二分法，先判断中值是属于哪边的升序序列，再根据端点值继续判断 target该落在左边还是右边区域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def search(self, nums, target):</span><br><span class="line">        start = 0</span><br><span class="line">        end = len(nums) - 1</span><br><span class="line">        while start &lt;= end:    # 当 start == end 的时候，mid 刚好等于start,所有数都判断了</span><br><span class="line">            mid = start + (end - start) // 2  # 注意用//，否则结果不为整数！</span><br><span class="line">            if nums[mid] == target:</span><br><span class="line">                return mid</span><br><span class="line">            if nums[mid] &gt;= nums[start]: # 左半边有序</span><br><span class="line">                if target &gt;= nums[start] and target &lt; nums[mid]:</span><br><span class="line">                    end = mid - 1</span><br><span class="line">                else:</span><br><span class="line">                    start = mid + 1</span><br><span class="line">            if nums[mid] &lt;= nums[end]:   # 右半边有序</span><br><span class="line">                if target &gt; nums[mid] and target &lt;= nums[end]:</span><br><span class="line">                    start = mid + 1</span><br><span class="line">                else:</span><br><span class="line">                    end = mid - 1</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure></p>
<h3 id="0034-在排序数组中查找元素的第一个和最后一个位置"><a href="#0034-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="0034. 在排序数组中查找元素的第一个和最后一个位置"></a>0034. 在排序数组中查找元素的第一个和最后一个位置</h3><p><strong>题目：</strong>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。<br><strong>解题思路：</strong>看到O(logn)的时间复杂度的查找，就首先想到了二分查找，使用传统的二分查找是找到和target相等的值的索引的时候，继续分头向前向后循环，直到找到不等于target的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>: <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target <span class="keyword">and</span> nums[<span class="number">-1</span>] &gt;= target:  <span class="comment"># target 在有序数组范围内</span></span><br><span class="line">            left, right = <span class="number">0</span>, length - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    right = left = mid</span><br><span class="line">                    <span class="keyword">while</span> left - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[left<span class="number">-1</span>] == target:</span><br><span class="line">                        left -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right + <span class="number">1</span> &lt;= length - <span class="number">1</span> <span class="keyword">and</span> nums[right + <span class="number">1</span>] == target:</span><br><span class="line">                        right += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> [left, right]</span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="0035-搜索插入位置"><a href="#0035-搜索插入位置" class="headerlink" title="0035. 搜索插入位置"></a>0035. 搜索插入位置</h3><p><strong>题目：</strong>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。假设数组中无重复元素。<br><strong>解题思路：</strong>二分法，注意最后返回的是left！！</p>
<ul>
<li>当left = right时，mid = left; </li>
<li>若target 比 mid 大，则left = left + 1, 加入原 left 之后；</li>
<li>若target 比 mid 小，则right = left(mid) - 1, 返回 left！！<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="0036-有效的数独"><a href="#0036-有效的数独" class="headerlink" title="0036. 有效的数独"></a>0036. 有效的数独</h3><p><strong>题目：</strong>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。数字 1-9 在每一行、每一列、每一个小 3x3 子宫内只能出现一次。<br><strong>解法一：</strong>用三个矩阵row、col、block 分别检查行、列、块是否有重复数字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:</span><br><span class="line">        # 注意这里不能用 [[False] * 9] * 9 来初始化，涉及到深浅拷贝的问题</span><br><span class="line">        row = [[False for i in range(9)] for j in range(9)]</span><br><span class="line">        col = [[False for i in range(9)] for j in range(9)]</span><br><span class="line">        block = [[False for i in range(9)] for j in range(9)]</span><br><span class="line">        for i in range(9):</span><br><span class="line">            for j in range(9):</span><br><span class="line">                if board[i][j] != &apos;.&apos;:</span><br><span class="line">                    num = int(board[i][j]) - 1    # 将字符串类型转换为数字</span><br><span class="line">                    k = (i // 3) * 3 + j // 3</span><br><span class="line">                    if row[i][num] or col[j][num] or block[k][num]:</span><br><span class="line">                        return False</span><br><span class="line">                    row[i][num] = col[j][num] = block[k][num] = True</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二：</strong>类似解法一，可以记录所有出现过的行、列、块的数字及相应的位置，最后判断是否有重复，用set操作精简代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        seen = []</span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board):</span><br><span class="line">            <span class="keyword">for</span> j, c <span class="keyword">in</span> enumerate(row):</span><br><span class="line">                <span class="keyword">if</span> c != <span class="string">'.'</span>:</span><br><span class="line">                    seen += [(c, j), (i, c), (i//<span class="number">3</span>, j//<span class="number">3</span>, c)]  <span class="comment"># 用元组记录每个符号出现的行号、列号和小九宫格位置，注意书写标记的差异！！区分(c, j)和(i, c)</span></span><br><span class="line">        <span class="keyword">return</span> len(seen) == len(set(seen))</span><br></pre></td></tr></table></figure></p>
<h3 id="0041-缺失的第一个正数"><a href="#0041-缺失的第一个正数" class="headerlink" title="0041. 缺失的第一个正数"></a>0041. 缺失的第一个正数</h3><p><strong>题目：</strong>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br><strong>解题思路：</strong>由于要找出缺少的第一个正数，可以把所有正数都放到对应的位置，再找到第一个位置不匹配的地方，即原本应该放的那个数。排序的方法就是依次遍历每个数字，把他们放到应该放置的位置，若输入为[1, 2, 0]，则已经排好了，若输入是[3, 4, -1, 1]，则需要排成[1, -1, 3, 4]，遍历时找到 nums[i] != i+1 的位置，如果所有位置都符合，说明数组是从1开始的连续正整数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">1</span> <span class="comment"># 缺失的最小正数是1</span></span><br><span class="line">        i, length = <span class="number">0</span>, len(nums)</span><br><span class="line">        <span class="keyword">while</span> i &lt; length:</span><br><span class="line">            current = nums[i]</span><br><span class="line">            <span class="keyword">if</span> current &lt;= <span class="number">0</span> <span class="keyword">or</span> current &gt; length <span class="keyword">or</span> nums[current - <span class="number">1</span>] == current:  <span class="comment"># 当前数为负数，或者超过length，或已经在该位置上</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[current - <span class="number">1</span>], nums[i] = nums[i], nums[current - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length + <span class="number">1</span>   <span class="comment"># 前面的正整数都在位！</span></span><br></pre></td></tr></table></figure></p>
<h3 id="0002-两数相加"><a href="#0002-两数相加" class="headerlink" title="0002. 两数相加"></a>0002. 两数相加</h3><p><strong>题目：</strong>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。假设除了数字 0 之外，这两个数都不会以 0 开头。示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="literal">None</span>: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">None</span>: <span class="keyword">return</span> l1</span><br><span class="line">        append = <span class="number">0</span></span><br><span class="line">        helper = ListNode(<span class="number">0</span>); </span><br><span class="line">        p = helper</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            p.next = ListNode((l1.val + l2.val + append) % <span class="number">10</span>)</span><br><span class="line">            append = (l1.val + l2.val + append) // <span class="number">10</span></span><br><span class="line">            l1 = l1.next; l2 = l2.next; p = p.next</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            p.next = ListNode((l2.val + append) % <span class="number">10</span>)</span><br><span class="line">            append = (l2.val + append) // <span class="number">10</span></span><br><span class="line">            l2 = l2.next; p = p.next</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            p.next = ListNode((l1.val + append) % <span class="number">10</span>)</span><br><span class="line">            append = (l1.val + append) // <span class="number">10</span></span><br><span class="line">            l1 = l1.next; p = p.next</span><br><span class="line">        <span class="keyword">if</span> append != <span class="number">0</span>:</span><br><span class="line">            p.next = ListNode(append)</span><br><span class="line">        <span class="keyword">return</span> helper.next</span><br></pre></td></tr></table></figure>
<h3 id="0019-删除链表的倒数第N个节点"><a href="#0019-删除链表的倒数第N个节点" class="headerlink" title="0019. 删除链表的倒数第N个节点"></a>0019. 删除链表的倒数第N个节点</h3><p><strong>题目：</strong>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br><strong>解题思路：</strong>建一个节点标记头节点，使用双指针 p1, p2，p1 先向前移动 n 个节点，然后 p1, p2 同时移动，当 p1.next == None时，<strong>p2.next 指向的就是要删除的节点</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        p1 = p2 = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">while</span> p1.next:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        p2.next = p2.next.next  <span class="comment"># p2.next 是要删除的节点！</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure></p>
<h4 id="0021-合并两个有序链表"><a href="#0021-合并两个有序链表" class="headerlink" title="0021. 合并两个有序链表"></a>0021. 合并两个有序链表</h4><p><strong>题目：</strong>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if l1 == None: return l2</span><br><span class="line">        if l2 == None: return l1</span><br><span class="line">        dummy = ListNode(0)</span><br><span class="line">        p = dummy</span><br><span class="line">        while l1 and l2:   # 节点不为空的写法</span><br><span class="line">            if l1.val &lt;= l2.val:</span><br><span class="line">                p.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">                p = p.next</span><br><span class="line">            else:</span><br><span class="line">                p.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">                p = p.next</span><br><span class="line">        if l2 == None:</span><br><span class="line">            p.next = l1</span><br><span class="line">        if l1 == None:</span><br><span class="line">            p.next = l2</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure></p>
<h3 id="0023-合并K个排序链表"><a href="#0023-合并K个排序链表" class="headerlink" title="0023. 合并K个排序链表"></a>0023. 合并K个排序链表</h3><p><strong>题目：</strong>合并 k 个排序链表，返回合并后的排序链表。<br><strong>解题思路：</strong>用最小堆实现，首先将每条链表的头节点压入堆中，将最小的弹出，并将最小的节点这条链表的下一个节点入堆，依次类推，直到最小堆为空，就得到一个排好序的列表。</p>
<p><strong>最小堆构建的复杂度为O(NlogN)</strong>，每次取最小值的复杂度为O(1)，向最小堆添加元素的复杂度是O(logN)，所以总的时间复杂度是O(NlogN)</p>
<p>下面是用python3提供的最小堆结构 heapq 实现的：</p>
<blockquote>
<p><strong>a 为 普通列表</strong>：</p>
<ul>
<li>heapq.heapify(a)  调整 a ，使其满足最小堆；</li>
<li>heapq.heappop(a) 从最小堆中弹出最小的元素</li>
<li>heapq.heappush(a, b) 向最小堆中压入新的元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:</span><br><span class="line">        heap = []</span><br><span class="line">        for node in lists:</span><br><span class="line">            while node:</span><br><span class="line">                heapq.heappush(heap, node.val) # 把所有list中所有node的值都放入最小堆，只存值！不留点！！</span><br><span class="line">                node = node.next</span><br><span class="line">        dummy = ListNode(0)</span><br><span class="line">        p = dummy</span><br><span class="line">        while heap:</span><br><span class="line">            small_val = heapq.heappop(heap)</span><br><span class="line">            p.next = ListNode(small_val)</span><br><span class="line">            p = p.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="0024-两两交换链表中的节点"><a href="#0024-两两交换链表中的节点" class="headerlink" title="0024. 两两交换链表中的节点"></a>0024. 两两交换链表中的节点</h3><p><strong>题目：</strong>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><strong>解题思路：</strong>设置两个节点，一个总是等于交换的第一个，另一个总是等于交换时第一个节点的前一个节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        pre, cur = dummy, head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">            pre.next = cur.next</span><br><span class="line">            cur.next = pre.next.next</span><br><span class="line">            pre.next.next = cur</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<p><strong>理清楚顺序：</strong>0 —&gt; 1 —&gt; 2 —&gt; 3 —&gt; 4 （交换1，2）0 —&gt; 2 —&gt; 1 —&gt; 3 —&gt; 4</p>
<ul>
<li>（1）0 指向2: pre.next = cur.next</li>
<li>（2）1 指向3: cur.next = pre.next.next</li>
<li>（3）2 指向1: pre.next.next = cur</li>
<li>（4）更新pre 和 cur: pre = cur, cur = cur.next</li>
</ul>
<p><strong>小结：</strong></p>
<ul>
<li>节点 Node 在指向其他人 （node.next = …）时要先把原来node指向的节点存起来；</li>
<li>要清楚当前已知的节点！！只用已知的节点表示链接关系！如上只知道 pre 和 cur 两个节点，在pre 和 cur 本身赋值其他前都用这两个节点表示！！</li>
</ul>
<h3 id="0025-K-个一组翻转链表"><a href="#0025-K-个一组翻转链表" class="headerlink" title="0025. K 个一组翻转链表"></a>0025. K 个一组翻转链表</h3><p><strong>题目</strong>：给定一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br><strong>解题思路：</strong>A—&gt;B—&gt;C—&gt;D—&gt;E , 现在要翻转 BCD 三个节点，分以下几步：</p>
<ul>
<li>（1）C —&gt; B</li>
<li>（2）D —&gt; C</li>
<li>（3）B —&gt; E</li>
<li>（4）A —&gt; D</li>
<li>（5）返回节点B</li>
</ul>
<p>也就是 0—&gt;1—&gt;2—&gt;3—&gt;4—&gt;5—&gt;6，要翻转1到4: <code>链表递归的写法！！</code></p>
<ul>
<li>（1）输入 0</li>
<li>（2）保存 1</li>
<li>（3）2指1，3指2，4指3</li>
<li>（4）0指4，1指5</li>
<li>（5）输出1！因为5之后也要反转了！</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur:   <span class="comment"># 当前节点不为空，递归</span></span><br><span class="line">            cur = self.reverseNextK(cur, k)</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseNextK</span><span class="params">(self, preHead, k)</span>:</span></span><br><span class="line">        <span class="comment"># 检查是否有 k 个</span></span><br><span class="line">        cur = preHead</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.next:  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 反转后的最后一个节点，即反转前的第一个节点 （1）</span></span><br><span class="line">        node = preHead.next  <span class="comment"># 反转前的第一个，反转后的最后一个</span></span><br><span class="line">        prev = preHead <span class="comment"># 反转前第一个的前一个</span></span><br><span class="line">        cur = preHead.next  <span class="comment"># 反转前的第一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使 k 个节点依次后指前 （2）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            nextNode = cur.next  <span class="comment"># 用一个临时结点存当前节点原本指向的节点</span></span><br><span class="line">            cur.next = prev    <span class="comment">#当前节点指向前一个</span></span><br><span class="line">            prev = cur  <span class="comment"># prev 更新为下次待翻转节点的前一个节点</span></span><br><span class="line">            cur = nextNode  <span class="comment"># cur 更新为下次要反指的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 反转结束时，cur为下一组k的第一个，即 k+1, prev 为第 k 个</span></span><br><span class="line">        <span class="comment"># 连接首位</span></span><br><span class="line">        node.next = cur  <span class="comment"># 反转前的第一个指向第k+1个 （3）</span></span><br><span class="line">        preHead.next = prev <span class="comment"># k 组整体的前一个节点指向第k个</span></span><br><span class="line">        <span class="keyword">return</span> node <span class="comment"># 返回反转后的最后一个！！供下次递归调用！！（4）</span></span><br></pre></td></tr></table></figure>
<h3 id="0003-无重复字符的最长子串"><a href="#0003-无重复字符的最长子串" class="headerlink" title="0003. 无重复字符的最长子串"></a>0003. 无重复字符的最长子串</h3><p><strong>题目：</strong>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br><strong>解题思路：哈希表 + 双指针</strong> ，用两个变量 start 和 end 分别记录子串的起点和终点，从左向右逐字符遍历原始字符串，每次将end + 1，字典countDict存储当前子串中各字符的个数，当新增字符c的计数 &gt; 1时，表明已有重复，向右移动起点start，并将s[start]在字典中的计数 -1，直到countDict[c]不大于1为止，更新最大长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        res, start, end = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        countDict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">            countDict[c] = countDict.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> countDict[c] &gt; <span class="number">1</span>:</span><br><span class="line">                countDict[s[start]] -= <span class="number">1</span>  <span class="comment"># 直到跳过s[start] 等于c的字符，start 指针停止</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            res = max(res, end - start)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="0005-最长回文子串"><a href="#0005-最长回文子串" class="headerlink" title="0005. 最长回文子串"></a>0005. 最长回文子串</h3><p><strong>题目：</strong>给定一个字符串 s，找到 s 中最长的回文子串。假设 s 的最大长度为 1000。<br><strong>解法一：动态规划法</strong><br>dp[i][j] 表示字符串区间 [i, j] 是否为回文串，当i=j时，只有一个字符，肯定是回文串，如果 i = j + 1，说明是相邻字符，此时是回文串的条件是s[i] == s[j]，如果i 和 j 不相邻，即 i-j &gt;=2 时，除了判断s[i] 和 s[j] 相等外，还要求dp[i + 1][j -1]为回文串。所以递推公式如下：</p>
<ul>
<li>dp[i,j] = 1 if i == j</li>
<li>dp[i,j] = s[i] == s[j]  if j = i + 1</li>
<li>dp[i,j] = s[i] == s[j] &amp;&amp; dp[i+1][j-1]  if j &gt; i + 1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(set(s)) == <span class="number">1</span>: <span class="keyword">return</span> s  <span class="comment"># set(s)对s去重！若都一样肯定是回文！！</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        start, end, maxL = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]   </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):   <span class="comment"># 后指针不超过字符串长度，遍历每一个以j结尾的字符串</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j): </span><br><span class="line">                dp[i][j] = (s[i] == s[j] <span class="keyword">and</span> ((j - i &lt; <span class="number">2</span>) | dp[i+<span class="number">1</span>][j<span class="number">-1</span>]))</span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> maxL &lt; j - i + <span class="number">1</span>:</span><br><span class="line">                    maxL = j - i + <span class="number">1</span></span><br><span class="line">                    start = i</span><br><span class="line">                    end = j</span><br><span class="line">            dp[j][j] = <span class="number">1</span>     <span class="comment"># i 始终取不到j！！</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end+<span class="number">1</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**解法二：中心扩展法**</span><br><span class="line">每个子串的中心（可以是一个字符，或者是两个字符的间隔，比如串abc，中心可以是a, b, c或者是 ab的间隔，bc的间隔，例如aba是回文，abba 也是回文，这两种情况要分情况考虑）往两边同时进行扫描，直到不是回文串为止。假设字符串的长度为n，那么**中心的个数为<span class="number">2</span> * n<span class="number">-1</span> (字符作为中心有 n个，间隔有n<span class="number">-1</span>个)，对于每个中心往两边扫描的复杂度为O(n)**，所以时间复杂度是$O((<span class="number">2</span>n - <span class="number">1</span>) n)=O(n^<span class="number">2</span>)$，空间复杂度O(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 0076. 最小覆盖子串</span></span><br><span class="line">**题目：**给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。示例：</span><br><span class="line">输入: S = <span class="string">"ADOBECODEBANC"</span>, T = <span class="string">"ABC"</span></span><br><span class="line">输出: <span class="string">"BANC"</span></span><br><span class="line">说明：如果 S 中不存这样的子串，则返回空字符串 <span class="string">""</span>。如果 S 中存在这样的子串，我们保证它是唯一的答案。</span><br><span class="line"></span><br><span class="line">**解题思路：**双字典对比！t 中的字符可能有重复字符，所以需要用字典记录每个字符出现的次数，要判断窗口中是否出现了所有字符，首先需要左右指针表示窗口的位置，还要有另外一个字典记录窗口中每个字符出现的次数。双指针扫描过程中，尾指针不断往后扫，当扫到有一个窗口包含了所有T的字符，就收缩头指针，直到不能再收缩位置。记录所有可能的情况中窗口最小的。</span><br><span class="line"></span><br><span class="line">注意本题的初始化方式！初始填满！！找到一个减一个！找齐后再一位一位往回缩！</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        countT = &#123;&#125;</span><br><span class="line">        countNeed = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> t:</span><br><span class="line">            countT[char] = countT.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        countNeed = countT</span><br><span class="line">        count = len(t)  <span class="comment"># 标记到目前为止还需要找的字符数</span></span><br><span class="line">        start = <span class="number">0</span>; minSize = sys.maxsize; minStart = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> countT <span class="keyword">and</span> countT[s[i]] &gt; <span class="number">0</span>:</span><br><span class="line">                countNeed[s(i)] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> countNeed[s(i)] &gt;= <span class="number">0</span>:</span><br><span class="line">                    count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:   <span class="comment"># t中的字符都找齐了</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[start] <span class="keyword">in</span> countT <span class="keyword">and</span> countT[]</span><br></pre></td></tr></table></figure>
<h4 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a>115. 不同的子序列</h4><p><strong>题目：</strong>给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p><strong>解题思路：</strong>动态规划，dp[i][j]表示S[0…i-1]中有多少子串是T[0…j-1]。</p>
<p><strong>注意</strong>子串匹配时长度的限制，目标子串的长度不能超过S的长度！设边界！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numDistinct(self, s: str, t: str) -&gt; int:</span><br><span class="line">        if len(t) &gt; len(s): return 0</span><br><span class="line">        dp = [[0 for i in range(len(s) + 1)] for j in range(len(t) + 1)]</span><br><span class="line">        for i in range(len(s) + 1):</span><br><span class="line">            dp[0][i] = 1</span><br><span class="line">            </span><br><span class="line">        for i in range(1, len(s) + 1):</span><br><span class="line">            for j in range(1, min(len(t) + 1, i+1)):  # j最多等于i，子串不等超过字符串S长度，j最多只能取到第i位或len(t)位</span><br><span class="line">                if s[i - 1] == t[j - 1]: # 如果新加的最后一位匹配</span><br><span class="line">                    dp[j][i] = dp[j][i-1] + dp[j-1][i-1] # dp[i-1][j-1]表示如果没有当前新加的这位，前面有多少种匹配方法，因为新加的这位相等，只是延长了匹配的子串长度！</span><br><span class="line">                else:</span><br><span class="line">                    dp[j][i] = dp[j][i-1] # dp[i-1][j]表示i-1长的s已经可以产生的与j匹配的子串个数，当s多一位时，前面依然可以匹配</span><br><span class="line">        return dp[len(t)][len(s)]</span><br></pre></td></tr></table></figure></p>
<h4 id="727-最小窗口子序列"><a href="#727-最小窗口子序列" class="headerlink" title="727. 最小窗口子序列"></a>727. 最小窗口子序列</h4><p><strong>题目：</strong>给定字符串S和T，在S中寻找最小连续子串W，使得T是W的子序列。如果没有找到返回””，如果找到多个最小长度的子串，返回左 index 最小的。<br><strong>解题思路：</strong>动态规划，确定一个子串的两个关键要素时起始位置和长度，dp[i][j] 表示 S 中前 i 个字符包含T中前 j 个字符的子串的起始位置，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, S, T)</span>:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        m = len(S)</span><br><span class="line">        n = len(T)</span><br><span class="line">        <span class="keyword">if</span> m &lt; n: <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        start = <span class="number">-1</span></span><br><span class="line">        minLen = sys.maxsize</span><br><span class="line">        dp = [[<span class="number">-1</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, min(i+<span class="number">1</span>, n+<span class="number">1</span>)):</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> S[i<span class="number">-1</span>] == T[j<span class="number">-1</span>]:</span><br><span class="line">                    </span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> dp[i][n] != <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> minLen &gt; i - dp[i][n]:</span><br><span class="line">                    minLen = i - dp[i][n]</span><br><span class="line">                    start = dp[i][n]</span><br><span class="line">        <span class="keyword">if</span> start != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> S[start: start + minLen]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>递归模版<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span><span class="params">(level, param1, param2, ...)</span>:</span></span><br><span class="line">    <span class="comment"># recursion terminator</span></span><br><span class="line">    <span class="keyword">if</span> level &gt; MAX_LEVEL:</span><br><span class="line">        print_result</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 当前层要做的事</span></span><br><span class="line">    process_data(level,data...)</span><br><span class="line">    <span class="comment"># 再入一层drill down</span></span><br><span class="line">	self.recursion(level + <span class="number">1</span>, p1, ...)</span><br><span class="line">	<span class="comment"># 恢复，将下探一层对本层的影响还原 reverse the current level status</span></span><br><span class="line">	reverse_state(level)</span><br></pre></td></tr></table></figure></p>
<p>DFS代码-递归写法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">visited = set()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, visited)</span>:</span></span><br><span class="line">    visited.add(node)</span><br><span class="line">    <span class="comment"># process current node here</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> next_node <span class="keyword">in</span> node.children():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> next_node <span class="keyword">in</span> visited:</span><br><span class="line">	        dfs(next_node, visited)</span><br></pre></td></tr></table></figure></p>
<p>BFS代码-递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(graph, start, end)</span>:</span></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append([start])</span><br><span class="line">    visited.add(start)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop()</span><br><span class="line">        visited.add(node)</span><br><span class="line">	    </span><br><span class="line">	    process(node)</span><br><span class="line">	    nodes = generate_related_nodes(node)</span><br><span class="line">	    queue.push(nodes)</span><br><span class="line">	<span class="comment"># other processing work</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure></p>
<p>二分查找<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">left, right = <span class="number">0</span>, len(array) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    <span class="comment"># ()left + right) / 2 可能会越界</span></span><br><span class="line">    mid = left + (right - left) / <span class="number">2</span>  </span><br><span class="line">    <span class="keyword">if</span> array[mid] == target:</span><br><span class="line">        <span class="comment"># find the target</span></span><br><span class="line">        <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">elif</span> array[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>DP模版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态定义</span></span><br><span class="line">dp = <span class="keyword">new</span> <span class="keyword">int</span> [m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = x;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = y;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// DP状态的推导</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">0</span>; ++i)&#123;</span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">		...</span><br><span class="line">		d[i][j] = min&#123;dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>], etc,&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m][n];   <span class="comment">// 最优解</span></span><br></pre></td></tr></table></figure></p>
<h3 id="位运算操作"><a href="#位运算操作" class="headerlink" title="位运算操作"></a>位运算操作</h3><ol>
<li>X &amp; 1 == 1 OR == 0  判断奇偶，比X%2==1效率更高</li>
<li>X = X &amp; (X - 1)  清零最低位的1</li>
<li>X &amp; -X  得到最低位的1</li>
</ol>
<h3 id="python-编程"><a href="#python-编程" class="headerlink" title="python 编程"></a>python 编程</h3><p>x, y = y, x 两个变量同时赋值</p>
<p><strong>反转链表 - reverse linked list</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    cur, prev = head, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        cur.next, prev, cur = prev, cur, cur.next</span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure></p>
<p><strong>链表交换相邻元素</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    result = ListNode(<span class="number">0</span>)     <span class="comment"># 返回链表的头节点dummy node</span></span><br><span class="line">    pre, pre.next = result, head</span><br><span class="line">    <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next:</span><br><span class="line">        a = pre.next</span><br><span class="line">        b = a.next</span><br><span class="line">        pre.next, b.next, a.next = b, a, b.next</span><br><span class="line">        pre = a</span><br><span class="line">    <span class="keyword">return</span> result.next</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>不要在舒适圈内久待，去刻意联系自己不熟悉的算法和数据结构。<br>做过的题目要返回再复习</p>
<p> 不要把面试官当作监考老师，把他当作工作伙伴，你们一起team work解决问题。</p>
<p> 面试答题四件套：</p>
<ol>
<li>Clarification，搞清楚题目干嘛，询问题目细节、边界条件、可能的极端错误情况</li>
<li>Possible Solution，所有可能的解法都和面试官沟通一遍</li>
</ol>
<ul>
<li>Compare Time &amp; Space Complexity </li>
<li>Optimal Solution</li>
</ul>
<ol>
<li>Coding</li>
<li>Test Cases (测试用例)</li>
</ol>
</blockquote>
<p><strong>工程中尽量少用递归？</strong><br>递归是机器运行代码的本质，或者说最常用的一种形式。</p>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>求解最快的办法是 O(logN)：</p>
<ul>
<li><p>通项公式<br><img src="./1561769334906.png" alt="Alt text"></p>
</li>
<li><p>矩阵相乘（完美）</p>
</li>
</ul>
<blockquote>
<p><strong>37%规则：</strong>在东西、房子等做选择的时候，前37%的都不选，只作为样本，后续的63%中只要遇到比前37%好的，就选Ta了。</p>
<p>——《 Algorithms to Live By》</p>
<p><strong>Priority Queue</strong><br>公司、项目组里最重要的事情是哪些，紧急程度怎样，哪些是你马上要做的。每个任务有一个密度，等于 重要程度 / 完成时间，根据自己的经验、老大决定</p>
</blockquote>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="矩阵连乘："><a href="#矩阵连乘：" class="headerlink" title="矩阵连乘："></a>矩阵连乘：</h3><p><strong>题目：</strong>给定 n 个矩阵 ${A_1, A_2, …, A_n}$，$A_i$ 和 $A_{i+1}$ 是可乘的，用加括号的方法表示矩阵连乘的次序，不同的计算次序计算量是不同的，找出一种加括号的方法，使得矩阵连乘的次数最小。<br><strong>解题思路：</strong> 矩阵 $A_{m\times n}$ 和 $B_{n\times k}$ 的乘法运算次数为 $m\times n \times k$ ，用 $dp[i][j]$ 表示从第 $i$ 个矩阵到第 $j$ 个矩阵的最少乘法次数，问题就变成了在 $i$ 和 $j$ 之间找一个 $k$，使得以 $left = (A_i A_{i+1} … A_k) ，right = (A_{k+1} A_{k+2}…A_{j})$ 划分时，$i$ 到 $j$ 的乘法次数最少。其中$left.shape=(Row_{A_i}, Col_{A_k})$，$right.shape = (Row_{A_{k+1}}, Col_{A_{j}})$，$left \times right $的计算次数为 $Row_{A_i} \times Col_{A_k} \times Col_{A_{j}}$</p>
<p>所以 dp 方程为：</p>
<script type="math/tex; mode=display">
dp[i][j] = 
\left\{
\begin {array}{}
0 & i = j \\
\mathop{min}\limits_{k}\{dp[i][k] + dp[k+1][j] + row_{A_i} \times col_{A_k} \times col_{A_{j}}\}
\end{array}
\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_matrix</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(matrix) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix))] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix))]  <span class="comment"># dp[i][j] 表示第i到第 j 的矩阵最小乘法次数 </span></span><br><span class="line">    seg = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix))] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix))]  <span class="comment"># seg[i][j] 表示第 i 到第 j 的矩阵最小乘法次数对应的一次划分</span></span><br><span class="line">    <span class="keyword">for</span> gap <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)): <span class="comment"># dp[i][i]初始化为0，用dp[i][i]计算dp[i][i+1]，用dp[i][[i] 的结果更新 dp[i][i+1], 用dp[i][i+1] 的结果更新 dp[i][i+2] ...</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix) - gap):</span><br><span class="line">            j = i + gap</span><br><span class="line">            seg[i][j] = i</span><br><span class="line">            dp[i][j] = dp[i][i] + dp[i+<span class="number">1</span>][j] + matrix[i][<span class="number">0</span>] * matrix[j][<span class="number">1</span>] * matrix[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(i + <span class="number">1</span>, j):</span><br><span class="line">                cur = dp[i][k] + dp[k+<span class="number">1</span>][j] + matrix[i][<span class="number">0</span>] * matrix[j][<span class="number">1</span>] * matrix[k][<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> cur &lt; dp[i][j]:</span><br><span class="line">                    dp[i][j] = cur</span><br><span class="line">                    seg[i][j] = k</span><br><span class="line">        <span class="keyword">print</span> (dp[i][j])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len(matrix)<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">matrix = [(<span class="number">5</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">6</span>), (<span class="number">6</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">10</span>), (<span class="number">10</span>, <span class="number">4</span>)]  </span><br><span class="line">multi_matrix(matrix) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 二叉树</span></span><br><span class="line"><span class="comment">### 94. 二叉树的中序遍历</span></span><br><span class="line">**【递归法】**</span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.recursiveInorder(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursiveInorder</span><span class="params">(self, root, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.recursiveInorder(root.left, res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            self.recursiveInorder(root.right, res)</span><br></pre></td></tr></table></figure>
<p><strong>【非递归法】</strong><br>堆栈/列表加 node 子节点时，一定是在 node pop时，不然会陷入死循环。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.iterativeInorder(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iterativeInorder</span><span class="params">(self, root, res)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root) <span class="comment"># 先把左子树放进堆栈</span></span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 直到左子树为空，弹出栈顶加入res，将其右子树的根节点压入堆栈，右子树的加入顺序也是从其左子树开始</span></span><br><span class="line">                root = stack.pop()</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a>95. 不同的二叉搜索树 II</h3><p><strong>题目：</strong>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p>
<p><strong>思路：</strong>求个数一般思路是动态规划，如果是枚举的话一般考虑dfs。dfs(start, end) 返回以start, start+1,…, end 为根的二叉查找树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generateTrees(self, n: int) -&gt; List[TreeNode]:</span><br><span class="line">        if n &lt;= 0: return []</span><br><span class="line">        return self.dfs(1, n)</span><br><span class="line">    </span><br><span class="line">    def dfs(self, start, end):</span><br><span class="line">        if start &gt; end:   # 递归终止条件！！！</span><br><span class="line">            return [None] # 注意有None且加[]!!表示子树为null!!</span><br><span class="line">        res = []</span><br><span class="line">        for rootVal in range(start, end + 1): # 用从start 到end(包括end)的每个值作为根节点构造二叉树</span><br><span class="line">            left = self.dfs(start, rootVal - 1) # 递归构造左子树</span><br><span class="line">            right = self.dfs(rootVal + 1, end)</span><br><span class="line">            for i in left: # 对于构造出的每颗左子树和右子树</span><br><span class="line">                for j in right:</span><br><span class="line">                    root = TreeNode(rootVal)</span><br><span class="line">                    root.left = i</span><br><span class="line">                    root.right = j</span><br><span class="line">                    res.append(root) # res并不是同一个res,每层递归内部都会建一个res!</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h3><p><strong>题目：</strong>给定一个二叉树，判断其是否是一个有效的二叉搜索树。二叉搜索树具有如下特征：（1）节点的左子树只包含小于当前节点的数；（2）节点的右子树只包含大于当前节点的数；（3）所有左子树和右子树自身必须也是二叉搜索树。</p>
<p><strong>思路：</strong>二叉搜索树的中序遍历时，若当前节点的值总是大于前一个节点的值，则返回真。</p>
<p><strong>【解法一】空间复杂度O(n)</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 空树是二分查找树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        List = []</span><br><span class="line">        self.inOrder(root, List)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(List)):</span><br><span class="line">            <span class="keyword">if</span> List[i] &lt;= List[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(self, root, List)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root: <span class="comment"># 递归终止条件</span></span><br><span class="line">            self.inOrder(root.left, List)</span><br><span class="line">            List.append(root.val)</span><br><span class="line">            self.inOrder(root.right, List)</span><br></pre></td></tr></table></figure></p>
<p><strong>【解法二】空间复杂度O(1)</strong>：用全局变量pre指向当前节点的前驱节点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        Bool = self.isValidBST(root.left) <span class="comment"># 先递归看左子树</span></span><br><span class="line">        <span class="keyword">if</span> self.pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            Bool = Bool <span class="keyword">and</span> self.pre.val &lt; root.val <span class="comment"># 左子树返回True 且当前根节点大于pre.val</span></span><br><span class="line">        self.pre = root</span><br><span class="line">        <span class="keyword">return</span> Bool <span class="keyword">and</span> self.isValidBST(root.right)  <span class="comment"># 递归检查右子树</span></span><br></pre></td></tr></table></figure></p>
<h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a>99. 恢复二叉搜索树</h3><p><strong>题目：</strong>二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。<br><strong>【解法一】空间复杂度O(n)</strong>：一颗二叉搜索树的中序遍历应该是升序的，对错误的二叉搜索树中序遍历，只需要把顺序恢复过来再进行重新赋值就可以了。用两个列表实现，list 用来存储被破坏的二叉搜索树节点值，listp用来存储二叉搜索树的节点指针。然后将list 排序，在用listp中存储的节点指针赋值就可以了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        List = []</span><br><span class="line">        Listp = []</span><br><span class="line">        self.inOrder(root, List, Listp)</span><br><span class="line">        List.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(Listp)):</span><br><span class="line">            Listp[i].val = List[i]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(self, root, List, Listp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.inOrder(root.left, List, Listp)</span><br><span class="line">            List.append(root.val)</span><br><span class="line">            Listp.append(root)</span><br><span class="line">            self.inOrder(root.right, List, Listp)</span><br></pre></td></tr></table></figure></p>
<p><strong>【解法二】空间复杂度O(1)</strong>用一个prev变量，在中序遍历时，当碰到第一个逆序时，将n1指向偏大值，再找第二个逆序，将n2指向偏小值，交换这两个节点值即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.n1 = self.n2 = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.FindTwoNode(root)</span><br><span class="line">        self.n1.val, self.n2.val = self.n2.val, self.n1.val <span class="comment"># 对于二叉树，只交换值！保留树的结构！</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindTwoNode</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.FindTwoNode(root.left) <span class="comment"># 还是要中序遍历，要比大小</span></span><br><span class="line">            <span class="keyword">if</span> self.prev <span class="keyword">and</span> self.prev.val &gt; root.val:</span><br><span class="line">                self.n2 = root  <span class="comment"># 如果找到一个不正常的小root,赋值给n2</span></span><br><span class="line">                <span class="keyword">if</span> self.n1 == <span class="literal">None</span>:  <span class="comment"># 如果n1还没有复制，说明当前找到的是第一个出错的，错的是偏大值，左移将prev赋值给n1</span></span><br><span class="line">                    self.n1 = self.prev</span><br><span class="line">            self.prev = root</span><br><span class="line">            self.FindTwoNode(root.right)</span><br></pre></td></tr></table></figure></p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });

</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->

</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/junlian.github.io/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/junlian.github.io/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
